## foreword.

 - Thật đáng kinh ngạc, và khá lúng túng, Để nhận ra có bao nhiêu phần mềm chúng tôi chạy mà không biết chắc chắn những gì nó làm. Chúng tôi mua phần mềm khỏi kệ trong những packages. Chúng tôi chạy tiện ích thiết lập cài đặt nhiều tệp, Thay đổi cài đặt hệ thống, Xóa hoặc vô hiệu hóa các phiên bản cũ hơn và các tiện ích không dùng đến , Và Sửa đổi các tệp đăng ký quan trọng. Mỗi lần chúng tôi truy cập một trang Web, Chúng ta có thể gọi hoặc tương tác với hàng chục chương trình và phân đoạn mã cần thiết để cho chúng ta nhìn, cảm nhận và hành vi dự định. Chúng tôi mua đĩa CD với hàng trăm trò chơi và các tiện ích hoặc tải chúng xuống như là phần mềm chia sẻ. Chúng tôi trao đổi các chương trình hữu ích với các đồng nghiệp và bạn bè khi chúng tôi đã cố gắng chỉ một phần tính năng của mỗi chương trình.
 (tức là mỗi người chỉ cố hiểu 1 phần tính năng của chương trình) 

 - Sau đó, chúng tôi tải về bản cập nhật và cài đặt bản vá lỗi,Tin tưởng vào các nhà cung cấp và chắc chắn rằng những thay đổi là chính xác và đầy đủ. Chúng tôi mù quáng hy vọng rằng sự thay đổi mới nhất cho mỗi chương trình sẽ giữ nó tương thích với tất cả các phần còn lại của chương trình trên hệ thống của chúng tôi. Chúng tôi dựa vào nhiều phần mềm mà chúng tôi không hiểu và không biết rõ lắm.

 - Tôi làm việc nhiều hơn với máy tính cá nhân hơn trên máy tính để bàn hoặc máy tính xách tay của chúng tôi. Khái niệm về tính toán phổ biến hoặc "phần mềm ở mọi nơi", nhanh chóng Đưa phần mềm kiểm soát và kết nối vào các thiết bị trong môi trường của chúng ta. Ô tô trung bình bây giờ có thêm nhiều dòng mã phần mềm trong bộ điều khiển động cơ của nó hơn là yêu cầu đưa các phi hành gia Apollo lên Mặt Trăng. 

 - Phần mềm ngày nay trở nên phức tạp và kết nối với nhau mà nhà phát triển Thường không biết tất cả các tính năng và hậu quả của những gì đã được Tạo trong một ứng dụng. Thông thường quá tốn kém và mất nhiều thời gian để kiểm tra tất cả các đường dẫn kiểm soát của một chương trình và tất cả các nhóm tùy chọn người dùng. Bây giờ, với nhiều lớp kiến trúc và sự bùng nổ của các nền tảng nối mạng mà phần mềm sẽ chạy hoặc tương tác với nhau, nó đã trở nên vô nghĩa đối với tất cả các kết hợp được kiểm tra và thử nghiệm. Giống như các vấn đề phát hiện tương tác thuốc, nhiều hệ thống phần mềm được thực hiện với các vấn đề không rõ ràng và không thể đoán trước.

 - Kỹ thuật đảo ngược là một tập hợp các kỹ thuật và công cụ để hiểu tất cả Những gì phần mềm thực sự làm. một cách chính thức , nó là "quá trình phân tích một vấn đề hệ thống để xác định các thành phần của hệ thống và các mối quan hệ tương hỗ và tạo ra các đại diện của hệ thống dưới dạng khác hoặc ở cấp độ trừu tượng cao hơn" (IEEE 1990). Điều này cho phép chúng ta hình dung cấu trúc của phần mềm, cách hoạt động của nó, và các tính năng điều khiển hành vi của nó. Các kỹ thuật phân tích và áp dụng các công cụ tự động để kiểm tra phần mềm, cho chúng ta một cách hợp lý để hiểu được sự phức tạp của phần mềm và để khám phá sự thật của nó

 - kỷ thuật dịch ngược đã có 1 quá trình dài. ý tưởng Quy trình đảo ngược xảy ra mỗi khi ai đó xem xét mã của người khác . Tuy nhiên, nó cũng xảy ra khi một nhà phát triển xem mã của chính mình vài ngày sau khi nó được viết. Kỹ thuật đảo ngược là một quá trình khám phá. Khi chúng ta nhìn vào mã nguồn, cho dù được phát triển bởi chính chúng ta hay của người khác, chúng tôi kiểm tra và chúng tôi học hỏi và chúng tôi thấy những điều mà chúng tôi không mong đợi.

 - Mặc dù đã là chủ đề của một số phiên họp tại hội nghị và các nhóm người sử dụng máy tính, nhưng kỹ thuật đảo ngược phần mềm đã đến tuổi thành niên năm 1990. Sự thừa nhận trong cộng đồng kỹ thuật thông qua việc xuất bản một nguyên tắc phân loại về kỹ thuật đảo ngược và các khái niệm khôi phục thiết kế trong tạp chí phần mềm IEEE .Kể từ đó, đã có rất nhiều nghiên cứu về kỹ thuật Reversing, hình dung phần mềm, hiểu chương trình, kỹ thuật đảo ngược dữ liệu, phân tích phần mềm và các công cụ và phương pháp liên quan. Các diễn đàn nghiên cứu, chẳng hạn như Hội nghị Quốc tế hàng năm về Đảo ngược Kỹ thuật (WCRE), khám phá, khuếch đại và mở rộng giá trị của các kỹ thuật hiện có. Hiện đang có sự quan tâm ngày càng tăng về việc đảo ngược nhị phân , trọng tâm chính của cuốn sách này là để hỗ trợ di chuyển nền tảng, khả năng tương tác, phát hiện phần mềm độc hại và xác định vấn đề

 - là 1 nhà quản lý và là 1 nhà chuyên môn về công nghệ thông tin, tôi thường hỏi: "Làm thế nào mà bạn có thể bỏ qua kỹ thuật đảo ngược?" Sau đó là theo sau: "Bạn đã phát triển và bán phần mềm Bạn không muốn người khác tôn trọng và bảo vệ bản quyền của bạn Và sở hữu trí tuệ? Thảo luận này thường bắt đầu từ ý nghĩa tiêu cực của thuật ngữ kỹ thuật đảo ngược, đặc biệt là trong các thỏa thuận cấp phép phần mềm. Tuy nhiên, các công nghệ kỹ thuật đảo ngược có giá trị theo nhiều cách cho người sản xuất và người tiêu dùng về phần mềm trong chuỗi cung ứng.

- Một ống nghe có thể được sử dụng bởi một tên trộm để nghe cơ chế khóa an toàn khi những chiếc lẫy khóa rơi xuống. Nhưng cùng một loại ống nghe có thể được bác sĩ gia đình sử dụng để phát hiện ra các vấn đề về hô hấp hay tim. Hoặc, nó có thể được sử dụng bởi kỹ thuật viên máy tính để lắng nghe kỹ lưỡng các âm thanh hoạt động của ổ đĩa bịt kín để chẩn đoán vấn đề mà không phơi bày ổ đĩa tới bụi và phấn hoa có thể gây hại. Công cụ không phải là vốn tốt hay xấu. Vấn đề là cách sử dụng công cụ được đưa ra.

 - Vào đầu những năm 1980, IBM quyết định rằng nó sẽ không còn tiết lộ cho khách hàng của mình mã nguồn cho các hệ điều hành máy tính lớn. Khách hàng của các hệ thống máy tính lớn luôn dựa vào mã nguồn để tham khảo trong việc giải quyết vấn đề và điều chỉnh, sửa đổi và mở rộng các sản phẩm hệ điều hành của IBM. Tôi vẫn có nút của tôi từ nhóm người sử dụng IBM chia sẻ rằng: "Nếu NGUỒN là bất hợp pháp, thì chỉ có kẻ cướp sẽ có NGUỒN", một trò chơi chữ trên một lý lẽ nổi tiếng của đối thủ của luật kiểm soát kẻ trộm. Áp dụng cho phần mềm hiện tại, điều này chỉ ra rằng các hacker và nhà phát triển mã độc hại biết rất nhiều kỹ thuật để giải mã phần mềm của người khác. Nó cũng rất hữu ích cho những kẻ tốt để biết những kỹ thuật.

 - Kỹ thuật đảo ngược đặc biệt hữu ích trong phân tích phần mềm hiện đại cho nhiều mục đích khác nhau:
<ul>
<li>Tìm mã độc hại. Nhiều kỹ thuật phát hiện vi rút và phần mềm độc hại sử dụng kỹ thuật đảo ngược để hiểu mã độc được cấu trúc và chức năng như thế nào. Thông qua Reversing, các mô hình nhận dạng xuất hiện có thể được sử dụng như là chữ ký để thúc đẩy các máy dò mã ít tốn kém và máy quét mã.</li>
<li>Khám phá những sai sót và sai lầm không mong muốn. Ngay cả những hệ thống được thiết kế tốt nhất cũng có thể có những lỗ hổng do bản chất của kỹ thuật phát triển "kỹ thuật tiên tiến" của chúng. Kỹ thuật đảo ngược có thể giúp xác định các sai sót và lỗi trước khi chúng trở thành các lỗi phần mềm quan trọng</li>
<li>Tìm hiểu việc sử dụng mã của người khác. Để hỗ trợ việc sử dụng tri thức về sở hữu trí tuệ, điều quan trọng là phải hiểu được nơi mà các mã hoặc kỹ thuật được bảo vệ được sử dụng trong các ứng dụng. Kỹ thuật đảo ngược kỹ thuật có thể được sử dụng để phát hiện sự hiện diện hoặc không có các yếu tố phần mềm liên quan.</li>
<li>Tìm việc sử dụng phần mềm chia sẻ và mã nguồn mở mà nó không được dự định sử dụng. Ngược lại với sự lo ngại về mã vi phạm, nếu một sản phẩm dành cho mục đích bảo mật hoặc sử dụng độc quyền, sự có mặt của mã công khai có thể là mối quan tâm. Kỹ thuật đảo ngược cho phép phát hiện các vấn đề lặp lại mã.</li>
<li>Học hỏi từ những sản phẩm khác của một tài sản khác hoặc mục đích khác.Kỹ thuật đảo ngược kỹ thuật có thể cho phép nghiên cứu các vấn đề phần mềm nâng cao và cho phép sinh viên mới khám phá các sản phẩm của các thạc sĩ. Đây có thể là một cách rất hữu ích để học hỏi và xây dựng trên cơ sở kiến thức mã nguồn ngày càng phát triển. Nhiều trang web đã được xây dựng bằng cách nhìn thấy những gì các trang web khác đã làm. Nhiều nhà phát triển Web đã học các kỹ thuật lập trình HTML và Web bằng cách xem các nguồn của các trang khác.</li>
<li>Khám phá các tính năng hoặc cơ hội mà các nhà phát triển ban đầu đã không nhận ra. Mã phức tạp có thể thúc đẩy đổi mới. Các kỹ thuật hiện tại có thể được sử dụng lại trong các ngữ cảnh mới. Kỹ thuật đảo ngược có thể dẫn tới những khám phá mới về phần mềm và những cơ hội mới cho sự đổi mới</li>
</ul>

 - Trong việc áp dụng các phương pháp tiếp cận CASE và hỗ trợ lập trình phần mềm tự động, trong việc phát triển hệ thống mới và bảo trì phần mềm, từ lâu tôi đã  cho rằng bất kỳ hệ thống nào chúng ta xây dựng phải chạy ngay lập tức thông qua một bộ công cụ kỹ thuật đảo ngược. Các lỗ hổng và các vấn đề được phát hiện sẽ giúp người dùng, khách hàng và nhân viên hỗ trợ nhiều giờ nỗ lực trong việc phát hiện vấn đề và giải pháp.

 - Tôi đã tham gia nghiên cứu và ứng dụng phần mềm kỹ thuật đảo ngược trong 30 năm, trên các máy tính lớn, các hệ thống tầm trung và máy tính cá nhân, từ các câu lệnh ngôn ngữ lập trình, các mô đun nhị phân, các tệp dữ liệu và các luồng điều khiển công việc. Trong thời gian đó, tôi đã nghe nhiều phương pháp giải thích và đã thấy nhiều kỹ thuật đã được thử. Ngay cả với bối cảnh đó, tôi đã học được rất nhiều từ cuốn sách này và quan điểm của nó về kỹ thuật đảo chiều. Tôi chắc chắn rằng bạn cũng sẽ như tôi

 Elliot Chikofsky
Engineering Management and Integration (Herndon, VA)
Chair, Reengineering Forum
Executive Secretary, IEEE Technical Council on Software Engineering

## Introduction
 
 - Chào mừng bạn đến với Reversing: Những bí mật của kỹ thuật ngược dòng. Cuốn sách này được viết sau nhiều năm làm việc về các dự án phát triển phần mềm liên tục yêu cầu kỹ thuật đảo ngược mã bên thứ ba vì nhiều lý do khác nhau. Lúc đầu, đây là một quá trình khá tẻ nhạt chỉ được thực hiện khi không có phương tiện thay thế nào để nhận thông tin. Rốt cục, một rào cản tinh thần nào đó đã bị phá vỡ và tôi thấy mình nhanh chóng lướt qua mã máy không dựa vào tài liệu, nhanh chóng giải mã ý nghĩa của nó và nhận được câu trả lời tôi muốn về chức năng và mục đích của mã. Vào thời điểm đó, tôi nhận thấy rằng đây là một kỹ năng mạnh mẽ đáng kể, bởi vì nó có nghĩa là tôi có thể dễ dàng nhận được câu trả lời cho bất kỳ câu hỏi nào tôi chú ý về phần mềm tôi đang làm việc, ngay cả khi tôi không có quyền truy cập vào các tài liệu có liên quan hoặc Mã nguồn của chương trình đang được đề cập. Cuốn sách này là về cung cấp kiến thức và kỹ thuật để cho phép bất cứ ai với một sự hiểu biết phong nha về phần mềm để làm điều đó.

 - Ý tưởng rất đơn giản: chúng ta nên phát triển sự hiểu biết vững chắc về phần mềm mức thấp và học các kỹ thuật cho phép chúng ta dễ dàng khai thác bất kỳ chương trình nhị phân nào và lấy thông tin. Bạn không chắc chắn tại sao một hệ thống hoạt động theo cách của nó và không ai khác có câu trả lời? Không có vấn đề - đào sâu vào nó một mình và tìm hiểu. Nghe có vẻ đáng sợ và không thực tế?Đây không phải là mục đích của cuốn sách này để giảng dạy và trình diễn các kỹ thuật đảo ngược kỹ thuật có thể được áp dụng hàng ngày để giải quyết nhiều vấn đề.

 - Nhưng tôi đang đi trước bản thân mình. Đối với những người bạn của bạn mà không được tiếp xúc với khái niệm về phần mềm kỹ thuật đảo ngược, đây là một giới thiệu nhỏ.

## Reverse Engineering and Low-Level Software

 - Trước khi chúng tôi đi vào các chủ đề khác nhau  được thảo luận trong suốt cuốn sách này, Chúng ta nên chính thức giới thiệu chủ đề chính. Kỹ thuật đảo ngược là một quá trình mà một thành phần lạ thiết kế (như một chiếc xe hơi, một động cơ phản lực hoặc một chương trình phần mềm) được giải cấu trúc theo cách cho thấy các chi tiết bên trong của nó, chẳng hạn như thiết kế và kiến trúc của nó. Điều này cũng tương tự như nghiên cứu khoa học để nghiên cứu các hiện tượng tự nhiên, với sự khác biệt là không ai thường đề cập đến nghiên cứu khoa học như kỹ thuật đảo ngược, đơn giản bởi vì không ai biết chắc chắn liệu thiên nhiên có được thiết kế hay không.

 - Trong thế giới phần mềm đảo ngược kỹ thuật boils xuống để có một chương trình hiện tại mà mã nguồn hoặc tài liệu hướng dẫn thích hợp là không có sẵn và cố gắng để khôi phục lại các chi tiết về thiết kế và thực hiện nó. Trong một số trường hợp mã nguồn có sẵn nhưng các nhà phát triển ban đầu đã làm cho nó không dùng được. Cuốn sách này đề cập cụ thể đến những gì thường được gọi là kỹ thuật đảo ngược nhị phân. Kỹ thuật đảo ngược nhị phân nhằm mục đích trích xuất thông tin có giá trị từ các chương trình mà mã nguồn không có sẵn.Trong một số trường hợp, có thể khôi phục mã nguồn thực tế (hoặc một đại diện mức cao tương tự) từ chương trình nhị phân, giúp làm đơn giản hóa công việc bởi vì đọc mã được trình bày bằng ngôn ngữ cấp cao dễ dàng hơn nhiều so với đọc cấp thấp Mã assembly. Trong các trường hợp khác chúng tôi kết thúc với một danh sách assembly khá khó hiểu mô tả chương trình. Cuốn sách này giải thích quá trình này và tại sao mọi thứ hoạt động theo cách này, trong khi mô tả chi tiết cách giải mã mã chương trình trong nhiều môi trường khác nhau.

> Tôi đã quyết định đặt tên cho cuốn sách này là "Reversing", là thuật ngữ được sử dụng bởi nhiều cộng đồng trực tuyến để mô tả kỹ thuật đảo ngược. Bởi vì thuật ngữ đảo ngược có thể được xem như một biệt hiệu cho kỹ thuật đảo ngược Tôi sẽ sử dụng hai thuật ngữ có thể hoán đổi trong suốt cuốn sách này.

 - Hầu hết mọi người đều có chút lo lắng khi họ cố gắng tưởng tượng việc cố gắng trích xuất các thông tin có ý nghĩa từ một tập tin thực thi nhị phân và tôi đã làm nó trở thành mục tiêu chính của cuốn sách này để chứng minh rằng nỗi sợ hãi này không được đúng đắn. kỹ thuật đảo ngược nhị phân hoạt động, nó có thể giải quyết các vấn đề mà thường khó có thể giải quyết bằng bất kỳ cách nào khác, và nó không phải là khó khăn như bạn nghĩ khi bạn tiếp cận nó một cách đúng.

 - Cuốn sách này tập trung vào kỹ thuật đảo ngược, nhưng nó thực sự dạy ta nhiều hơn thế. Kỹ thuật đảo ngược thường được sử dụng trong nhiều môi trường trong ngành công nghiệp phần mềm và một trong những mục tiêu chính của cuốn sách này là khám phá những lĩnh vực này trong khi dạy kỹ thuật đảo ngược.

 - Dưới đây là danh sách ngắn về một số chủ đề thảo luận trong cuốn sách này
<ul>
<li>Ngôn ngữ assembly cho bộ vi xử lý tương thích IA-32 và cách đọc mã ngôn ngữ lắp ráp tạo ra trình biên dịch.</li>
<li>bên trong Hệ điều hành và làm thế nào để đảo ngược một hệ điều hành</li>
<li>Kỹ thuật đảo ngược trên nền .NET, bao gồm giới thiệu về nền tảng phát triển .NET và ngôn assembly của nó: MSIL</li>
<li>kỹ thuật đảo ngược Dữ liệu: làm thế nào để giải mã một định dạng tập tin không có cơ sở hoặc giao thức mạng.</li>
<li>Các khía cạnh pháp lý của kỹ thuật đảo ngược: khi nào thì hợp pháp và khi nào thì không?</li>
<li>Sao chép bảo vệ và kỹ thuật quản lý quyền kỹ thuật số</li>
<li>Kỹ thuật đảo ngược được ứng dụng như thế nào qua bẻ khóa để chiến thắng kỹ thuật bảo vệ chống sao chép</li>
<li>Kỹ thuật để ngăn chặn người từ mã của kỹ thuật đảo ngược và một nỗ lực tỉnh táo để đánh giá hiệu quả của họ.</li>
<li>Các nguyên tắc chung đằng sau các chương trình độc hại hiện đại và cách thức kỹ thuật đảo ngược được áp dụng để nghiên cứu và vô hiệu hóa các chương trình như vậy.</li>
<li>Một phiên làm việc trực tiếp, nơi một chương trình độc hại thực tế bị cắt và tiết lộ, cũng cho thấy cách kẻ tấn công có thể giao tiếp với chương trình để kiểm soát các hệ thống bị nhiễm</li>
<li>Lý thuyết và nguyên tắc đằng sau trình biên dịch, và hiệu quả của chúng trên các ngôn ngữ cấp thấp khác nhau.</li>
</ul>

## Sách được tổ chức như thế nào?

 - Cuốn sách này được chia thành bốn phần. Phần thứ nhất cung cấp những điều cơ bản sẽ được yêu cầu để thực hiện những phần còn lại của văn bản, và ba kịch bản khác nhau về các kỹ thuật đảo ngược và minh họa các nghiên cứu điển hình thực tế. Sau đây là mô tả chi tiết của từng phần

 **Phần I - Đảo ngược 101:** Cuốn sách mở ra với một cuộc thảo luận về tất cả những điều cơ bản cần thiết để hiểu các phần mềm cấp thấp. Như bạn mong đợi, những chương này không thể bao gồm mọi thứ, và nênChỉ được xem như là một cuộc khảo sát làm mới các tài liệu bạn đã học trước đây. Nếu tất cả hoặc hầu hết các chủ đề thảo luận trong ba chương đầu tiên của cuốn sách này là hoàn toàn mới đối với bạn, thì cuốn sách này có lẽ không phải dành cho bạn. Các chủ đề chính được nghiên cứu trong các chương này là: Giới thiệu về kỹ thuật đảo ngược và các ứng dụng khác nhau của nó (chương 1), khái niệm phần mềm mức thấp (chương 2) và các hệ điều hành bên trong, với trọng tâm là Microsoft Windows (chương 3). Nếu bạn có nhiều kinh nghiệm với các chủ đề này và với phần mềm mức thấp nói chung, bạn có thể bỏ qua những chương này. Chương 4 thảo luận về các loại công cụ kỹ thuật đảo ngược được sử dụng và đề xuất các công cụ cụ thể phù hợp với nhiều tình huống. Nhiều công cụ trong số đó được sử dụng trong các phiên kỹ thuật đảo ngược được trình bày trong suốt cuốn sách này.

 - **Part II – ứng dụng của dịch ngược** Phần thứ hai của cuốn sách thể hiện các dự án kỹ thuật ngược thực sự được thực hiện trên phần mềm thực. Mỗi chương tập trung vào một loại ứng dụng kỹ thuật đảo ngược khác. Chương 5 thảo luận về kịch bản hay phổ biến, nơi một hệ điều hành hoặc thư viện của bên thứ ba được thiết kế ngược lại để tận dụng tốt hơn các dịch vụ nội bộ và API của nó.Chương 6 thể hiện cách giải mã một định dạng tệp tin không có giấy tờ, không bản quyền bằng cách áp dụng kỹ thuật kỹ thuật đảo ngược dữ liệu. Chương 7 cho thấy các nhà nghiên cứu điểm yếu chương trình có thể tìm kiếm các lỗ hổng trong các tệp tin thực thi nhị phân bằng cách sử dụng kỹ thuật đảo ngược. Cuối cùng, chương 8 thảo luận về phần mềm độc hại như virus và bọ và cung cấp một giới thiệu về chủ đề này. Chương này cũng chứng tỏ một phiên kỹ thuật đảo ngược thực sự trên một chương trình độc hại thực sự, đó là chính xác những gì các chương trình nghiên cứu phần mềm độc hại thường phải trải qua để nghiên cứu các chương trình độc hại, đánh giá những rủi ro mà chúng gây ra và tìm hiểu cách loại bỏ chúng.
 - **Part III – Vi phạm bản quyền và bảo vệ sao chép** Phần này tập trung vào kỹ thuật đảo ngược của một số loại mã bảo mật nhất định như bảo vệ bản quyền và kỹ thuật Quản lý quyền kỹ thuật số (DRM). Chương 9 giới thiệu chủ đề và thảo luận các nguyên tắc chung liên quan đến các công nghệ bảo vệ bản quyền. Chương 10 mô tả các kỹ thuật chống đảo ngược kỹ thuật như những kỹ thuật được sử dụng trong công nghệ chống sao chép và DRM và đánh giá hiệu quả của chúng. Chương 11 cho thấy kỹ thuật đảo ngược được sử dụng bởi "bẻ khóa" để đánh bại cơ chế bảo vệ bản quyền và ăn cắp nội dung được bảo vệ chống sao chép.
 
 - **Part IV – ngoài lề việc tháo gỡ** Phần cuối cùng của cuốn sách này chứa các tài liệu vượt xa việc tháo gỡ các chương trình thực thi đơn giản. Chương 12 thảo luận quy trình đảo ngược kỹ thuật cho các chương trình dựa trên máy ảo được viết dưới nền tảng phát triển Microsoft .NET.Chương này cung cấp giới thiệu về nền tảng .NET và hợp ngữ mức thấp, MSIL (Microsoft Intermediate Language). Chương 13 thảo luận về chủ đề lý thuyết sâu hơn về biên dịch lại, và giải thích cách trình biên dịch hoạt động và tại sao biên dịch mã nguồn lắp ráp bằng ngôn ngữ tự nhiên có thể rất khó khăn.
 
 - **phụ lục** Cuốn sách có ba phụ lục đóng vai trò tham khảo đắc lực khi bạn cố gắng giải mã các chương trình được viết bằng ngôn ngữ lắp ráp Intel IA-32. Ngoài các hướng dẫn tham khảo ngôn ngữ lắp ráp đơn giản, các phần phụ lục này mô tả các đoạn mã phổ biến và các thành ngữ trình biên dịch phát ra bởi trình biên dịch phổ biến để đáp ứng các trình tự mã điển hình và cách xác định và giải mã chúng.

## Ai nên đọc cuốn sách này ?
 
 -Cuốn sách này trình bày các kỹ thuật có thể có lợi cho người dân từ nhiều lĩnh vực. Các nhà phát triển phần mềm quan tâm đến việc nâng cao hiểu biết về các khía cạnh cấp thấp của phần mềm: hệ điều hành, ngôn ngữ lắp ráp, biên soạn, v.v. Chắc chắn sẽ được hưởng lợi. Quan trọng hơn, bất kỳ ai quan tâm đến việc phát triển các kỹ thuật cho phép họ nghiên cứu và điều tra mã hiện có một cách nhanh chóng và hiệu quả, cho dù đó là hệ điều hành, thư viện phần mềm hay bất kỳ thành phần phần mềm nào. Ngoài các kỹ thuật được dạy, cuốn sách này cũng cung cấp một cuộc hành trình hấp dẫn thông qua nhiều chủ đề như an ninh, kiểm soát bản quyền, và những thứ khác. Thậm chí nếu bạn không đặc biệt quan tâm đến kỹ thuật đảo ngược nhưng tìm thấy một hoặc nhiều tiểu chủ đề thú vị, bạn sẽ được hưởng lợi từ cuốn sách này.
 
 - Về các điều kiện tiên quyết, cuốn sách này đề cập đến một số tài liệu kỹ thuật khá tiên tiến và tôi đã cố gắng làm cho nó tự chứa đựng càng nhiều càng tốt. Phần lớn các yêu cầu cơ bản được yêu cầu sẽ được giải thích trong phần đầu của cuốn sách. Tuy nhiên, một lượng kiến thức và kinh nghiệm phát triển phần mềm nhất định sẽ là điều cần thiết để thực sự hưởng lợi từ cuốn sách này. Nếu bạn không có bất kỳ kinh nghiệm phát triển phần mềm chuyên nghiệp nào nhưng hiện đang trong quá trình nghiên cứu chủ đề này, có thể bạn sẽ có được lợi ích từ đây. Ngược lại, nếu bạn chưa bao giờ chính thức nghiên cứu máy tính nhưng đã được lập trình trong một vài năm, có thể bạn sẽ có thể được hưởng lợi từ cuốn sách này. Cuối cùng, cuốn sách này có lẽ sẽ hữu ích cho người đọc nâng cao hơn những kinh nghiệm với phần mềm cấp thấp và kỹ thuật đảo ngược những người muốn tìm hiểu một số kỹ thuật tiên tiến thú vị và làm thế nào để trích xuất thông tin chi tiết đáng giá từ mã hiện có.

## công cụ và nền tảng.

 - Kỹ thuật đảo ngược xoay quanh một loạt các công cụ được yêu cầu để có làm được việc. Những công cụ này được giới thiệu và thảo luận trong suốt cuốn sách này, và tôi đã cố ý dựa vào hầu hết các ví dụ của tôi về các công cụ miễn phí, để người đọc có thể theo dõi mà không cần phải bỏ ra hàng ngàn đô la cho các công cụ. Tuy nhiên, trong một số trường hợp, các dự án kỹ thuật đảo ngược lớn có thể được hưởng lợi từ một số sản phẩm đắt tiền. Tôi đã cố gắng cung cấp càng nhiều thông tin càng tốt về mọi công cụ có liên quan và để chứng minh hiệu quả của nó trong quá trình này.Cuối cùng, nó sẽ tùy thuộc vào người đọc để quyết định xem dự án có đảm bảo chi phí hay không.

 - Kỹ thuật đảo ngược thường là nền tảng cụ thể. Nó bị ảnh hưởng bởi hệ điều hành cụ thể và nền tảng phần cứng được sử dụng. Hệ điều hành chính được sử dụng trong cuốn sách này là Microsoft Windows, và vì một lý do chính đáng. Windows là môi trường kỹ thuật đảo ngược phổ biến nhất, và không chỉ vậy vì nó là hệ điều hành phổ biến nhất nói chung. Ví dụ, sự thay thế mã nguồn mở đáng yêu Linux của nó ít có liên quan đến quan điểm đảo ngược một cách chính xác vì hệ điều hành và phần lớn phần mềm chạy trên nó là mã nguồn mở. Không có điểm trong việc đảo ngược các sản phẩm mở - mà chỉ cần đọc mã nguồn, hoặc tốt hơn nữa,  hãy yêu cầu nhà phát triển ban đầu cho câu trả lời và nó Không có bí mật.

 - Trang web của cuốn sách có thể được truy cập tại http://www.wiley.com/go/eeilam, và chứa các chương trình mẫu được nghiên cứu trong suốt cuốn sách. Tôi cũng đã thêm liên kết đến các mẩu giấy, sản phẩm và tài nguyên trực tuyến khác nhau được thảo luận trong suốt cuốn sách.

 - ** chúng ta bắt đầu từ đâu**  cuốn sách được thiết kế để đọc liên tục từ đầu đến cuối. Tất nhiên, một số người sẽ được hưởng lợi nhiều hơn từ chỉ đọc các chương lựa chọn mà họ quan tâm. Về nơi bắt đầu, bất kể nền tảng của bạn, tôi khuyên bạn nên ghé thăm Chương 1 để đảm bảo rằng bạn có tất cả các tài nguyên liên quan đến kỹ thuật đảo ngược cơ bản. Nếu bạn không có bất kỳ kỹ thuật đảo ngược đáng kể hoặc kinh nghiệm phần mềm cấp thấp, tôi khuyên bạn nên đọc cuốn sách này theo thứ tự "tự nhiên", ít nhất là hai phần đầu tiên của nó. Nếu bạn có nhiều kinh nghiệm và cảm thấy như bạn đã quen thuộc việc phát triển phần mềm và các hệ điều hành, bạn có thể bỏ qua Chương 4 và đi qua các công cụ kỹ thuật đảo ngược.

# Reversing 101

## CHAPTER 1 : Foundations (cơ sở)
 - Chương này cung cấp một số thông tin cơ bản về kỹ thuật đảo ngược và các chủ đề khác nhau được thảo luận trong suốt cuốn sách này. Chúng tôi bắt đầu bằng cách định nghĩa kỹ thuật đảo ngược và các loại ứng dụng khác nhau có trong phần mềm và tiến hành để chứng minh mối liên hệ giữa phần mềm cấp thấp và kỹ thuật đảo ngược. Sau đó có một giới thiệu ngắn gọn về quá trình  kỹ thuật đảo ngược và các công cụ của thương mại. Cuối cùng, có một cuộc thảo luận về các khía cạnh pháp lý của kỹ thuật đảo ngược với một nỗ lực để phân loại các trường hợp trong đó kỹ thuật đảo ngược là hợp pháp và không hợp pháp. 

### dịch ngược là gì ?

 - Kỹ thuật đảo ngược là quá trình phân giải kiến thức hoặc thiết kế bản thiết kếTừ bất cứ thứ gì nhân tạo. Khái niệm đã có từ lâu trước khi máy tính hoặc công nghệ hiện đại xuất hiện, và có thể là trở lại những ngày của cuộc cách mạng công nghiệp. Nó rất giống với nghiên cứu khoa học, trong đó một nhà nghiên cứu đang cố gắng tìm ra "kế hoạch chi tiết" của nguyên tử hoặc tâm trí con người. Sự khác biệt giữa kỹ thuật đảo ngược và nghiên cứu khoa học thông thường là với kỹ thuật đảo ngược các hiện vật được điều tra là con người được thực hiện, không giống như nghiên cứu khoa học, nơi nó là một hiện tượng tự nhiên. Kỹ thuật đảo ngược thường được tiến hành để có được kiến thức, ý tưởng và triết lý thiết kế bị mất khi thông tin đó không có. trong một số trường hợp, thông tin thuộc về một số người mà họ không sẵn lòng chia sẽ chúng, trong một số trường hợp khác thông tin bị mất hoặc bị phá hủy. 

 - Theo truyền thống, kỹ thuật đảo ngược đã được hiểu là việc sử dụng các sản phẩm bao bì thu nhỏ và cắt bỏ vật lý chúng để khám phá những bí mật của thiết kế bên trong của nó. Những điều như vậy thường được sử dụng để tạo ra những sản phẩm tương tự hoặc tốt hơn. Trong nhiều ngành công nghiệp, kỹ thuật đảo ngược liên quan đến việc kiểm tra sản phẩm dưới kính hiển vi hoặc tách nó ra và tìm ra những gì mỗi phần làm được.

 - Cách đây không lâu, kỹ thuật đảo ngược thực sự là một sở thích khá phổ biến, được thực hiện bởi một số lượng lớn người (ngay cả khi nó không được gọi là kỹ thuật đảo ngược). hãy nhớ đến những ngày đầu của điện tử hiện đại như thế nào, Nhiều người đã rất ngạc nhiên bởi các thiết bị hiện đại như đài phát thanh và truyền hình và rằng nó đã trở thành thực sự phổ biến để tách chúng ra và xem những gì đi vào bên trong? Đó là kỹ thuật đảo ngược. Tất nhiên, những tiến bộ trong ngành công nghiệp điện tử đã làm chocông việc này ít có liên quan hơn. Các thiết bị điện tử kỹ thuật số hiện đại đã được thu nhỏ lại đến mức ngày nay bạn thực sự không thể thấy nhiều thứ thú vị bằng cách mở hộp.

### Phần mềm Kỹ thuật ngược: Đảo ngược 

 - Phần mềm là một trong những công nghệ phức tạp và hấp dẫn nhất hiện nay, và kỹ thuật đảo ngược phần mềm là mở "hộp" của chương trình và nhìn vào bên trong. phía trong. Tất nhiên, chúng tôi sẽ không cần bất kỳ tua vít nào trong quá trình này. Giống như kỹ thuật phần mềm, kỹ thuật đảo ngược phần mềm là một quá trình thuần túy ảo, liên quan đến chỉ một CPU và tâm trí con người.

 - Kỹ thuật đảo ngược phần mềm đòi hỏi sự kết hợp của các kỹ năng và sự hiểu biết thấu đáo về máy tính và phát triển phần mềm, nhưng giống như hầu hết các môn học đáng giá, điều kiện tiên quyết nhất là sự tò mò và ham muốn học hỏi. Phần mềm đảo ngược kỹ thuật tích hợp một số nghệ thuật:phá mã, giải quyết câu đố, lập trình, và phân tích logic. Quá trình này được sử dụng bởi nhiều người khác nhau cho nhiều mục đích khác nhau, nhiều trong số đó sẽ được thảo luận trong suốt cuốn sách này

 **đảo ngược ứng dụng**

 - Sẽ là công bằng khi nói rằng trong hầu hết các ngành công nghiệp kỹ thuật đảo ngược với mục đích phát triển sản phẩm cạnh tranh là ứng dụng nổi tiếng nhất của kỹ thuật đảo ngược. Điều thú vị là nó thực sự không phổ biến trong ngành công nghiệp phần mềm như ta mong đợi. Có nhiều lý do cho điều này, nhưng chủ yếu là do phần mềm quá phức tạp nên trong nhiều trường hợp kỹ thuật đảo ngược vì mục đích cạnh tranh được cho là quá trình phức tạp mà nó không có ý nghĩa về tài chính.

 - vậy thì, các ứng dụng phổ biến của kỹ thuật đảo ngược trong thế giới phần mềm là gì. Nói chung, có hai loại ứng dụng công nghệ đảo ngược: liên quan đến an ninh và phát triển phần mềm. Các phần sau đây trình bày các ứng dụng đảo ngược khác nhau trong cả hai loại.

** dịch ngược liên quan đến bảo mật**

 - Đối với một số người, mối liên hệ giữa an ninh và đảo chiều có thể không rõ ràng ngay lập tức. Đảo ngược có liên quan đến một số khía cạnh khác nhau của bảo mật máy tính. Ví dụ, đảo ngược đã được sử dụng trong nghiên cứu mã hóa - một nhà nghiên cứu đảo ngược một sản phẩm mã hóa và đánh giá mức độ bảo mật nó cung cấp. Đảo ngược cũng được sử dụng nhiều trong kết nối với phần mềm độc hại, trên cả hai đầu của rào cản: Nó được sử dụng bởi cả hai, những nhà phát triển phần mềm độc hại và những người phát triển chương trình giải độc. Cuối cùng, đảo chiều là rất phổ biến với những người sử dụng crackers để phân tích và cuối cùng đánh bại các chương trình bảo vệ bản quyền khác nhau. Tất cả các ứng dụng này được thảo luận trong các phần tiếp theo.

 ** Phần mềm độc hại**
 
 - Internet đã hoàn toàn thay đổi ngành công nghiệp máy tính nói chung và các khía cạnh liên quan đến an ninh của máy tính nói riêng. Phần mềm độc hại, như virus và sâu, lây lan nhanh hơn rất nhiều trong một thế giới mà hàng triệu người dùng được kết nối với Internet và sử dụng e-mail hàng ngày. Chỉ 10 năm trước, virus thường phải sao chép chính nó vào một đĩa mềm và đĩa đó sẽ phải được nạp vào một máy tính khác để virus lây lan. Quá trình lây nhiễm khá chậm, và việc phòng vệ đơn giản hơn rất nhiều vì các kênh lây nhiễm rất ít và cần sự can thiệp của con người vào chương trình lây lan. Đó là tất cả lịch sử cổ đại - Internet đã tạo ra một kết nối ảo giữa hầu hết các máy tính trên trái đất. Ngày nay, virus hiện đại có thể lây lan tự động tới hàng triệu máy tính mà không có sự can thiệp của con người.

 - Đảo ngược được sử dụng rộng rãi ở cả hai đầu của chuỗi phần mềm độc hại. Các nhà phát triển phần mềm độc hại thường sử dụng đảo ngược để tìm các lỗ hổng trong hệ điều hành và các phần mềm khác. Những lỗ hổng này có thể được sử dụng để xâm nhập vào các lớp phòng vệ của hệ thống và cho phép lây nhiễm-thường là qua Internet. Ngoài việc lây nhiễm, thủ phạm đôi khi sử dụng kỹ thuật đảo ngược để xác định vị trí các lỗ hổng phần mềm cho phép một chương trình độc hại truy cập thông tin nhạy cảm hoặc thậm chí kiểm soát hoàn toàn hệ thống. Ở đầu kia của mắc xích, các nhà phát triển phần mềm chống virus phân tích và phân tích mọi chương trình độc hại rơi vào tay của họ. Họ sử dụng kỹ thuật đảo ngược để theo dõi từng bước chương trình mất và đánh giá thiệt hại nó có thể gây ra, tỷ lệ dự kiến lây nhiễm, làm thế nào nó có thể được gỡ bỏ khỏi hệ thống bị nhiễm bệnh, và liệu có thể tránh được lây nhiễm hoàn toàn. Chương 8 là phần giới thiệu về thế giới của phần mềm độc hại và chứng tỏ việc viết chương trình chống virus sử dụng phương pháp đảo chiều như thế nào. Chương 7 trình bày cách các lỗ hổng phần mềm có thể được đặt ra bằng cách sử dụng kỹ thuật đảo ngược.

  ** đảo ngược thuật toán mã hóa**

 - Mật mã luôn dựa trên bí mật: Alice gửi tin nhắn cho Bob, và mã hóa tin nhắn đó bằng cách sử dụng một bí mật với hy vọng chỉ được biết với cô ấy và Bob. thuật toán mã hóa Có thể được chia thành hai nhóm: các thuật toán hạn chế Và thuật toán dựa trên khóa; Các thuật toán bị giới hạn là loại mà trẻ em chơi với một lá thư viết cho một người bạn với mỗi chữ cái đã dịch chuyển một vài chữ cái lên hoặc xuống. Bí mật trong thuật toán giới hạn là thuật toán nằm trong chính nó. Một khi thuật toán được tiếp xúc, nó không còn an toàn. Các thuật toán bị hạn chế cung cấp bảo mật rất kém vì đảo ngược làm cho nó rất khó khăn để duy trì sự bí mật của thuật toán. Một khi người đảo ngược đụng tay vào chương trình mã hóa hoặc giải mã, chỉ cần một khoảng thời gian trước khi thuật toán được khám phá. Bởi vì các thuật toán là bí mật, đảo ngược có thể được xem như là một cách để phá vỡ các thuật toán.

 - Mặt khác, trong các thuật toán dựa trên khóa, bí mật là một khoá, một số giá trị số được sử dụng bởi thuật toán để mã hóa và giải mã tin nhắn.. Trong thuật toán dựa trên khóa người dùng mã hóa tin nhắn sử dụng các khóa được giữ riêng tư. Các thuật toán thường được công khai, và các phím được giữ bí mật (và đôi khi được tiết lộ cho người nhận hợp pháp, tùy theo thuật toán). Điều này gần như làm cho đảo ngược vô nghĩa vì thuật toán đã được biết. Để giải mã thông điệp được mã hóa bằng mật mã dựa trên khóa, bạn sẽ phải::
  <ul>
  <li> Lấy chìa khóa</li>
  <li> Hãy thử tất cả các kết hợp có thể cho đến khi bạn nhận được chìa khóa</li>
  <li> Tìm kiếm một lỗ hổng trong thuật toán có thể được sử dụng để trích xuất khoá hoặc giải thư gốc</li>
  </ul>
 - Ngay cả khi thuật toán mã hóa được biết đến, chi tiết thực hiện cụ thể có thể thường có tác động bất ngờ đến mức độ bảo mật chung được cung cấp bởi một chương trình . Và sai sót triển khai nhỏ đôi khi có thể làm mất hiệu lực hoàn toàn mức độ an ninh được cung cấp bởi các thuật toán như vậy. Cách duy nhất để thực sự biết chắc chắn liệu một sản phẩm bảo mật có thực hiện thuật toán mã hóa thật sự an toàn hay là phải đi qua mã nguồn của nó (giả sử nó có sẵn) hoặc để đảo ngược nó.

 ** chương trình kiểm soát binaries**

 - Một trong những thế mạnh của phần mềm nguồn mở là nó thường đáng tin cậy và an toàn hơn. Bất kể an ninh thực sự cung cấp, nó chỉ cảm thấy an toàn hơn nhiều khi chạy phần mềm thường xuyên được kiểm tra và chấp thuận bởi hàng ngàn kỹ sư phần mềm không thiên vị. Không cần phải nói, phần mềm nguồn mở cũng cung cấp một số lợi ích chất lượng thực, hữu hình. Với phần mềm nguồn mở, việc truy cập mã nguồn của chương trình có nghĩa là một số lỗ hổng và lỗ hổng bảo mật nhất định có thể được phát hiện rất sớm, thường là trước khi các chương trình nguy hiểm có thể lợi dụng chúng. Với phần mềm độc quyền mà mã nguồn không có sẵn, việc đảo chiều trở thành một giải pháp thay thế có thể tồn tại (nhưng chưa được công nhận là hạn chế) để tìm kiếm các lỗ hổng bảo mật. Tất nhiên, kỹ thuật đảo ngược không thể làm cho phần mềm độc quyền gần như có thể truy cập và đọc được như phần mềm mã nguồn mở, nhưng kỹ năng đảo ngược mạnh mẽ cho phép người ta xem mã và đánh giá các rủi ro bảo mật khác nhau nó đặt ra. Tôi sẽ trình diễn loại kỹ thuật đảo ngược này trong chương 7

 ** Đảo ngược trong phát triển phần mềm **

 - Đảo ngược có thể vô cùng hữu ích cho các nhà phát triển phần mềm. Chẳng hạn, các nhà phát triển phần mềm có thể sử dụng kỹ thuật đảo ngược để khám phá cách tương tác với phần mềm không có dẫn chứng hoặc phần mềm có dẫn chứng. Trong các trường hợp khác, đảo chiều có thể được sử dụng để xác định chất lượng của mã bên thứ ba, chẳng hạn như thư viện mã hoặc thậm chí là một hệ điều hành. Cuối cùng đôi khi có thể sử dụng các kỹ thuật đảo chiều để lấy thông tin có giá trị từ sản phẩm của một đối thủ cạnh tranh cho mục đích cải tiến công nghệ của riêng bạn. Các ứng dụng đảo chiều trong phát triển phần mềm được thảo luận trong các phần sau.

 **có Khả năng Tương tác với Phần mềm thuộc sở hữu**

 - Khả năng tương tác là nơi phần lớn các kỹ sư phần mềm có thể hưởng lợi từ việc đảo chiều gần như hàng ngày. Khi làm việc với một thư viện phần mềm độc quyền hoặc API của hệ điều hành, tài liệu hầu như luôn luôn không đủ. Bất kể có bao nhiêu rắc rối của nhà cung cấp thư viện đã đảm bảo rằng tất cả các trường hợp có thể được bao gồm trong tài liệu, người dùng gần như luôn luôn thấy mình vạch ra trong đầu của họ với câu hỏi chưa được trả lời. Hầu hết các nhà phát triển hoặc khăng khăng và tiếp tục cố gắng bằng cách nào đó có được mọi thứ để làm việc, hoặc liên hệ với nhà cung cấp để có câu trả lời. Mặt khác, những người có kỹ năng đảo ngược thường sẽ thấy nó dễ dàng để đối phó với những tình huống như vậy. Sử dụng đảo ngược có thể giải quyết nhiều vấn đề này trong thời gian rất ít và với một nỗ lực tương đối nhỏ. Chương 5 và 6 thể hiện một số ứng dụng khác nhau để đảo ngược trong bối cảnh đạt được khả năng tương tác.

 **Phát triển phần mềm cạnh tranh**

 - Như tôi đã đề cập, trong hầu hết các ngành công nghiệp, đây là ứng dụng kỹ thuật đảo ngược phổ biến nhất. Phần mềm có xu hướng phức tạp hơn hầu hết các sản phẩm và do đó việc đảo ngược toàn bộ sản phẩm phần mềm nhằm tạo ra một sản phẩm cạnh tranh không có ý nghĩa. Việc thiết kế và phát triển sản phẩm từ đầu dễ dàng hơn hoặc đơn giản hơn là cho phép các thành phần phức tạp hơn từ bên thứ ba thay vì phát triển chúng trong nhà. Trong ngành công nghiệp phần mềm, ngay cả khi đối thủ cạnh tranh có một công nghệ không có bằng sáng chế (và tôi sẽ nhận được vào / vấn đề thương mại bí mật bằng sáng chế sau trong chương này), nó sẽ không bao giờ làm cho có ý nghĩa để thiết kế đối chiếu toàn bộ sản phẩm của họ. Nó gần như luôn luôn dễ dàng hơn để phát triển độc lập phần mềm của riêng bạn. Ngoại lệ là thiết kế / thuật toán phức tạp hoặc độc nhất rất khó khăn hoặc tốn kém để phát triển. Trong những trường hợp như vậy, hầu hết các ứng dụng vẫn phải được phát triển độc lập, nhưng phức tạp hoặc các thành phần bất thường có thể được đảo ngược và thực hiện lại trong sản phẩm mới. Các khía cạnh pháp lý của loại kỹ thuật đảo ngược này được thảo luận trong phần pháp lý ở phần sau của chương này.
 **Đánh giá Chất lượng Phần mềm và Tính mạnh mẽ**

 - Cũng như có thể kiểm tra một chương trình nhị phân để đánh giá tính bảo mật và tính dễ bị tổn thương của nó, cũng có thể thử và lấy mẫu chương trình nhị phân để có được ước tính về chất lượng chung của các thực hành mã hóa được sử dụng trong chương trình. Sự cần thiết rất giống nhau: phần mềm mã nguồn mở là một cuốn sách mở cho phép người dùng đánh giá chất lượng của nó trước khi cam kết. Các nhà cung cấp phần mềm không công bố mã nguồn của phần mềm mà chủ yếu yêu cầu khách hàng "chỉ tin tưởng vào họ. Nó giống như việc mua một chiếc xe đã qua sử dụng mà bạn không thể bật mui xe lên. Bạn không có ý tưởng gì bạn đang thực sự mua

 - Sự cần thiết phải có mã nguồn để truy cập vào các sản phẩm phần mềm quan trọng như hệ điều hành đã được làm rõ bởi các tập đoàn lớn; Vài năm trước đây Microsoft đã thông báo rằng khách hàng lớn mua hơn 1.000 chỗ ngồi có thể truy cập vào mã nguồn Windows cho mục đích đánh giá. Những người thiếu sức mua để thuyết phục một tập đoàn lớn cấp cho họ quyền truy cập vào mã nguồn của sản phẩm phải lấy từ của công ty rằng sản phẩm đó được xây dựng tốt hoặc sử dụng để đảo chiều. Một lần nữa, việc đảo chiều sẽ không bao giờ tiết lộ nhiều về chất lượng mã của sản phẩm và độ tin cậy tổng thể khi xem xét mã nguồn, tuy nhiên nó có thể mang lại nhiều thông tin. Không có kỹ thuật đặc biệt nào được yêu cầu ở đây. Ngay khi bạn đủ thoải mái với việc đảo chiều mà bạn có thể nhanh chóng đi qua mã nhị phân, bạn có thể sử dụng khả năng đó để thử và đánh giá chất lượng của nó. Cuốn sách này cung cấp mọi thứ bạn cần để làm đi

### phần mềm bậc thấp.

 - phần mềm bậc thấp ( hay còn gọi là phần mềm hệ thống) là một cái tên chung cho cơ sở của thế giới phần mềm. Nó bao gồm các công cụ phát triển như trình biên dịch, mối liên kết, và trình gỡ lỗi, phần mềm cơ sở như hệ điều hành, và các ngôn ngữ lập trình cấp thấp như hợp ngữ . Đó là lớp ngăn cách giữa các nhà phát triển phần mềm và các chương trình ứng dụng từ phần cứng vật lý. Các công cụ phát triển cô lập các nhà phát triển phần mềm từ các kiến trúc bộ xử lý và các ngôn ngữ lắp ráp, trong khi các hệ điều hành cách ly các nhà phát triển phần mềm từ các thiết bị phần cứng cụ thể và đơn giản hóa tương tác với người dùng bằng cách quản lý màn hình hiển thị, chuột, bàn phím, vân vân. 

 - Nhiều năm trước, các lập trình viên luôn phải làm việc ở mức thấp này bởi vì đó là cách duy nhất để viết phần mềm -khi cơ sở hạ tầng cấp thấp chưa không tồn tại. Ngày nay, các hệ điều hành hiện đại và các công cụ phát triển nhằm mục đích cô lập chúng tôi từ các chi tiết của thế giới cấp thấp. Điều này làm đơn giản hoá quá trình phát triển phần mềm, nhưng lại giảm chi phí và giảm sức mạnh kiểm soát hệ thống.

 - Để trở thành một kỹ sư đảo ngược giỏi, bạn phải phát triển một sự hiểu biết vững chắc về phần mềm mức thấp và chương trình cấp thấp. Đó là bởi vì các khía cạnh cấp thấp của một chương trình thường là điều duy nhất bạn phải làm việc như là một chi tiết cấp cao ngược lại hầu như luôn được loại bỏ trước khi một chương trình phần mềm được chuyển đến khách hàng. Thạc sỹ về phần mềm cấp thấp và các khái niệm về công nghệ phần mềm khác nhau cũng quan trọng , bằng cách nắm vững các kỹ thuật đảo ngược thực tế nếu như bạn trở thành một người đảo ngược giỏi

 - Một khái niệm quan trọng về việc đảo chiều sẽ trở nên rõ ràng trong cuốn sách này là các công cụ đảo chiều như tháo rời hoặc trình giải mã không bao giờ thực sự cung cấp câu trả lời-chúng chỉ trình bày thông tin. Cuối cùng, nó luôn luôn cần đến reverser để trích xuất bất cứ điều gì có ý nghĩa từ thông tin đó. Để trích xuất thành công thông tin trong một phiên đảo chiều, người đảo ngược phải hiểu các khía cạnh khác nhau của phần mềm cấp thấp.

 - Vì vậy, chính xác thì phần mềm cấp thấp là gì? . Máy tính và phần mềm được xây dựng trên các lớp, Tại lớp dưới cùng, Có hàng triệu bóng bán dẫn cực nhỏ xung nhịp với tốc độ không thể hiểu nổi.Ở lớp trên cùng, cho tac có một số đồ họa tao nhã, bàn phím và chuột - đó là trải nghiệm của người dùng. Hầu hết các nhà phát triển phần mềm sử dụng ngôn ngữ cấp cao có các lệnh dễ hiểu và thực hiện chúng. Ví dụ, các lệnh tạo một cửa sổ, tải một trang Web, hoặc hiển thị một hình ảnh rất cao cấp, có nghĩa là họ dịch cho hàng ngàn hoặc thậm chí hàng triệu lệnh ở các lớp thấp hơn. 

 - Đảo ngược đòi hỏi một sự hiểu biết vững chắc về những lớp dưới này. người dịch ngược phải biết rõ về bất cứ điều gì xảy ra giữa mã nguồn của chương trình và CPU. Các phần sau giới thiệu những khía cạnh của phần mềm cấp thấp bắt buộc để đảo ngược thành công

### assembly - hợp ngữ

 - hợp ngữ là cấp độ thấp nhất trong chuỗi ngôn ngữ lập trình, điều này làm cho nó vô cùng phù hợp cho dịch ngược-không có gì thay đổi mà không có nó. Nếu phần mềm thực hiện một thao tác, Nó phải được hiển thị trong mã ngôn ngữ lắp ráp. hợp ngữ là ngôn ngữ của dịch ngược. Làm chủ thế giới đảo chiều, Người ta phải phát triển một sự hiểu biết vững chắc về ngôn ngữ lắp ráp của nền tảng đã chọn. Điều này đưa chúng ta đến điểm cơ bản nhất để nhớ về ngôn ngữ lắp ráp: nó là một lớp ngôn ngữ chứ không phải là một ngôn ngữ. Mỗi nền tảng máy tính có ngôn ngữ lắp ráp riêng của nó mà thường là khá khác nhau từ tất cả các phần còn lại. Một khái niệm quan trọng để thoát ra khỏi con đường là mã máy (thường được gọi là mã nhị phân, hoặc mã đối tượng). Đôi khi người ta mắc lỗi khi nghĩ rằng mã máy là "nhanh hơn" hoặc "thấp hơn" so với ngôn ngữ lắp ráp. Đó là một quan niệm sai lầm: mã máy và ngôn ngữ lắp ráp là hai đại diện khác nhau của cùng một điều. Một CPU đọc mã máy, đó là không có gì, nhưng chuỗi các bit có chứa một danh sách các hướng dẫn cho CPU để thực hiện. Ngôn ngữ hội chỉ đơn giản là một biểu diễn văn bản của những bit-chúng ta đặt tên các phần tử trong các trình tự mã này để làm cho chúng có thể đọc được của con người. Thay vì các số thập lục phân bí ẩn, chúng ta có thể xem các tên lệnh văn bản như MOV (Move), XCHG (Exchange), v.v.
 - Mỗi lệnh ngôn ngữ lắp ráp được đại diện bởi một số, được gọi là mã hoạt động, hoặc opcode. Mã đối tượng cơ bản là một chuỗi các mã opcodes và các số khác được sử dụng trong kết nối với các opcodes để thực hiện các hoạt động. CPU liên tục đọc mã đối tượng từ bộ nhớ, giải mã nó, và hành động dựa trên các hướng dẫn nhúng vào nó. Khi các nhà phát triển viết mã bằng ngôn ngữ lắp ráp (một sự xuất hiện khá hiếm hoi những ngày này), họ sử dụng một chương trình lắp ráp để dịch mã văn bản lắp ráp văn bản thành mã nhị phân, có thể được giải mã bởi một CPU. Theo hướng khác và có liên quan nhiều hơn đến câu chuyện của chúng tôi, người tháo dời sẽ làm ngược lại. Nó đọc mã đối tượng và tạo ra bản đồ văn bản của mỗi hướng dẫn trong nó. Đây là một hoạt động tương đối đơn giản để thực hiện vì ngôn ngữ lắp ráp bằng văn bản đơn giản là một biểu hiện khác nhau của mã đối tượng. Tháo dỡ là một công cụ quan trọng cho người đảo ngược và sẽ được thảo luận sâu hơn trong phần sau của chương này.

 - Bởi vì ngôn ngữ lắp ráp là một vấn đề nền tảng cụ thể, chúng ta cần phải chọn một nền tảng cụ thể để tập trung vào trong khi học ngôn ngữ và thực hành đảo ngược. Tôi đã quyết định tập trung vào kiến trúc Intel IA-32, trên mỗi máy tính 32-bit. Lựa chọn này là một cách dễ dàng để thực hiện, xem xét sự phổ biến của máy tính cá nhân và của kiến trúc này. IA-32 là một trong những kiến trúc CPU phổ biến nhất trên thế giới, và nếu bạn đang lên kế hoạch học ngôn ngữ lập trình và đảo ngược và không có nền tảng cụ thể nào trong đầu, hãy đi với IA-32. Kiến trúc và ngôn ngữ lắp ráp của CPU dựa trên IA-32 được giới thiệu trong Chương 2.

 **Trình biên dịch**

 - Vì vậy, xem xét rằng CPU chỉ có thể chạy mã máy, làm thế nào là các ngôn ngữ lập trình phổ biến như C + + và Java dịch sang máy mã? Một tệp văn bản có chứa các hướng dẫn mô tả chương trình bằng ngôn ngữ cấp cao được đưa vào trình biên dịch. Trình biên dịch viên là một chương trình lấy tệp nguồn và tạo tệp mã máy tương ứng. Tùy thuộc vào ngôn ngữ cấp cao, mã máy này có thể là mã đối tượng nền tảng tiêu chuẩn được giải mã trực tiếp bởi CPU hoặc có thể được mã hoá trong một định dạng độc lập nền tảng được gọi là bytecode (xem phần sau về bytecode) .

 - Trình biên dịch của các ngôn ngữ lập trình truyền thống (không dựa trên byte mã) như C và C ++ trực tiếp tạo ra mã đối tượng có thể đọc bởi máy từ mã nguồn gốc văn bản. Điều này có nghĩa mã đối tượng là kết quả, khi dịch sang ngôn ngữ lắp ráp bởi một trình giải quyết, chủ yếu là một chương trình ngôn ngữ lắp ráp được tạo bằng máy. Tất nhiên, nó không phải là hoàn toàn máy, bởi vì các nhà phát triển phần mềm mô tả trình biên dịch những gì cần phải được thực hiện trong ngôn ngữ cấp cao. Nhưng các chi tiết về cách thức được thực hiện như thế nào được đảm nhiệm bởi trình biên dịch. Nhưng các chi tiết về cách thức thực hiện các công việc được thực hiện bởi trình biên dịch, cho kết quả là mã đối tượng. Đây là một điểm quan trọng bởi vì mã này không phải là luôn luôn dễ hiểu, thậm chí khi so sánh với một chương trình ngôn ngữ lắp ráp nhân tạo nó hoàn toàn khác biệt với con người.

 - Khó khăn lớn nhất trong việc giải mã biên dịch tạo ra là sự tối ưu hóa được áp dụng bởi hầu hết các trình biên dịch hiện đại. Trình biên dịch sử dụng nhiều kỹ thuật giảm kích thước mã và cải thiện hiệu suất thực thi. Vấn đề là các mã được tối ưu hóa kết quả thường là phản trực giác và khó đọc. Ví dụ, tối ưu hóa trình biên dịch thường thay thế các hướng dẫn đơn giản với các phép toán tương đương toán học mà mục đích của nó có thể không rõ ràng ngay từ cái nhìn đầu tiên.

 - Các phần quan trọng của cuốn sách này được dành riêng cho nghệ thuật giải mã ngôn ngữ lắp ráp máy tạo ra. Chúng tôi sẽ nghiên cứu một số vấn đề cơ bản về trình biên dịch trong Chương 2 và tiến hành các kỹ thuật cụ thể có thể được sử dụng để trích xuất thông tin có ý nghĩa từ mã biên dịch tạo ra
 **Máy ảo và Bytecode**

 - Trình biên dịch cho các ngôn ngữ cấp cao như Java tạo ra một bytecode thay vì một mã đối tượng. Bytecode tương tự như các mã đối tượng, ngoại trừ mã thường được giải mã bởi một chương trình, thay vì một CPU. Ý tưởng là có một trình biên dịch tạo ra bytecode, và để sau đó sử dụng một chương trình được gọi là một máy ảo để giải mã các bytecode và thực hiện các hoạt động được mô tả trong nó. Tất nhiên, máy ảo tự nó phải ở một số điểm chuyển mã bytecode thành mã đối tượng tiêu chuẩn tương thích với nền tảng của CPU 

 - Có một số lợi ích chính để sử dụng ngôn ngữ dựa trên bytecode. Một lợi thế đáng kể là nền tảng độc lập. Máy ảo có thể được chuyển đến các nền tảng khác nhau, cho phép chạy cùng một chương trình nhị phân trên bất kỳ CPU nào miễn là nó có một máy ảo tương thích. Tất nhiên, bất kể nền tảng nào mà máy ảo hiện đang chạy, định dạng bytecode vẫn giữ nguyên. Điều này có nghĩa là về mặt lý thuyết các nhà phát triển phần mềm không cần phải lo lắng về khả năng tương thích nền tảng. Tất cả những gì họ phải làm là cung cấp cho khách hàng của họ một phiên bản bytecode của chương trình của họ.Khách hàng phải lần lượt có được một máy ảo tương thích với cả hai ngôn ngữ bytecode cụ thể và với nền tảng cụ thể của họ. Sau đó, chương trình sẽ chạy trên nền tảng của người sử dụng mà không cần sửa đổi hoặc làm việc theo nền tảng.

 - Cuốn sách này tập trung chủ yếu vào kỹ thuật đảo ngược các chương trình thực thi tự nhiên được tạo ra bởi các trình biên dịch mã máy tự nhiên. Các chương trình đảo ngược được viết bằng các ngôn ngữ dựa trên bytecode là một quá trình hoàn toàn khác thường đơn giản hơn nhiều so với quá trình đảo ngược các tệp thực thi bản địa. Chương 12 tập trung vào kỹ thuật đảo chiều cho các chương trình được viết cho nền tảng .NET của Microsoft, sử dụng một máy ảo và một ngôn ngữ bytecode mức thấp.

 **hệ điều hành**
 - Một hệ điều hành là một chương trình quản lý máy tính, bao gồm phần cứng và các ứng dụng phần mềm. Một hệ điều hành chăm sóc nhiều nhiệm vụ khác nhau và có thể được xem như một loại điều phối giữa các yếu tố khác nhau trong máy tính. Hệ điều hành là yếu tố then chốt trong máy tính mà bất kỳ người đảo ngược nào cũng phải hiểu rõ những gì họ làm và cách chúng hoạt động. Như chúng ta sẽ thấy sau đó, nhiều kỹ thuật đảo chiều quay xung quanh hệ điều hành bởi vì hệ điều hành phục vụ như là một người giữ cổng điều khiển liên kết giữa các ứng dụng và thế giới bên ngoài. Chương 3 giới thiệu về kiến trúc hệ điều hành hiện đại và nội bộ hệ điều hành, và thể hiện sự kết nối giữa các hệ điều hành và kỹ thuật đảo ngược kỹ thuật

 ** quá trình dịch ngược**

 - làm sao để bắt đầu dịch ngược? Có rất nhiều cách tiếp cận khác nhau mà làm việc,Và tôi sẽ cố gắng thảo luận càng nhiều càng tốt trong suốt cuốn sách này.Đối với người mới bắt đầu, tôi thường cố gắng phân chia các phiên đảo ngược thành hai giai đoạn riêng biệt. Việc đầu tiên, thực sự là một loại quan sát quy mô lớn của chương trình trước đó, được gọi là  **_đảo ngược cấp độ hệ thống_** . Các kỹ thuật đảo chiều cấp hệ thống giúp xác định cấu trúc chung của chương trình và đôi khi thậm chí xác định các khu vực đáng quan tâm trong đó. Một khi bạn thiết lập một sự hiểu biết chung về cách bố trí của chương trình và xác định các lĩnh vực quan tâm đặc biệt bên trong nó, bạn có thể tiến hành công việc sâu hơn bằng cách sử dụng các kỹ thuật đảo ngược cấp mã. Kỹ thuật mức mã cung cấp thông tin chi tiết về đoạn mã đã chọn. Các phần sau sẽ mô tả từng kỹ thuật.

 **đảo ngược cấp độ hệ thống **

 - Liên quan đến việc chạy các công cụ khác nhau trong chương trình và sử dụng các dịch vụ hệ điều hành khác nhau để có được thông tin, kiểm tra các chương trình thực thi, theo dõi chương trình đầu vào và đầu ra, vv. Hầu hết các thông tin này đến từ hệ điều hành, bởi vì theo định nghĩa mọi sự tương tác mà một chương trình với thế giới bên ngoài phải trải qua qua hệ điều hành. Đây là lý do tại sao người đảo ngược phải hiểu hệ điều hành - chúng có thể được sử dụng trong các phiên đảo chiều để thu được nhiều thông tin về chương trình mục tiêu đang được điều tra. Tôi sẽ thảo luận về các vấn đề cơ bản của hệ điều hành trong Chương 3 và tiếp tục giới thiệu các công cụ khác nhau thường được sử dụng để đảo ngược cấp hệ thống trong Chương 4.

 **đảo ngược cấp độ mã**

 - đảo ngược cấp độ mã thật sự là một nghệ thuật. Trích xuất các khái niệm thiết kế và các thuật toán từ chương trình nhị phân là một quá trình phức tạp đòi hỏi phải có kỹ thuật đảo chiều cùng với sự hiểu biết vững chắc về phát triển phần mềm, CPU và hệ điều hành. Phần mềm có thể rất phức tạp, và thậm chí cả những người có quyền truy cập vào mã chương trình được viết tốt và có tài liệu chính xác của chương trình thì cũng thường kinh ngạc trước sự khó hiểu của nó. Giải mã các trình tự của các hướng dẫn mức thấp tạo nên một chương trình thường không có nghĩa là bạn đã làm được. Tuy nhiên, đừng lo lắng, trọng tâm của cuốn sách này là cung cấp cho bạn kiến thức, công cụ và kỹ thuật cần thiết để thực hiện đảo ngược mã cấp hiệu quả.

 - Trước khi bao gồm bất kỳ kỹ thuật thực tế, bạn phải làm quen với một số điều cần thiết về công nghệ phần mềm. Sự đảo ngược cấp mã quan sát mã từ mức rất thấp, và chúng ta sẽ nhìn thấy mọi chi tiết nhỏ về cách phần mềm hoạt động. Nhiều trong số các chi tiết này được tạo ra tự động bởi trình biên dịch và không phải do nhà phát triển phần mềm, mà đôi khi làm cho nó khó hiểu cách nó liên quan đến chương trình và chức năng của nó. Đó là lý do tại sao đảo chiều yêu cầu sự hiểu biết vững chắc về các khía cạnh cấp thấp của phần mềm, bao gồm liên kết giữa các cấu trúc lập trình cao cấp và cấp thấp, ngôn ngữ lắp ráp, và các hoạt động bên trong trình biên dịch. Các chủ đề này được thảo luận trong Chương 2.

 **công cụ**

 - đảo ngược là tất cả về công cụ . Các phần sau mô tả các loại công cụ cơ bản được sử dụng trong kỹ thuật đảo ngược. Nhiều công cụ này không được tạo ra cụ thể như là công cụ đảo chiều, nhưng dù sao nó củng có thể khá hữu ích. Chương 4 cung cấp một cuộc thảo luận chuyên sâu về các loại công cụ và giới thiệu các công cụ cụ thể sẽ được sử dụng trong suốt cuốn sách này. Chúng ta hãy cùng xem xét các loại công cụ khác nhau mà bạn sẽ xử lý

 ** công cụ giám sát hệ thống **

 - revese cấp hệ thống đòi hỏi nhiều công cụ giám sát, theo dõi , khám phá và nếu không thì chương trình sẽ bị đảo ngược. Hầu hết các công cụ này hiển thị thông tin thu thập được bởi hệ điều hành về ứng dụng và môi trường của nó. Bởi vì hầu hết các giao tiếp giữa một chương trình và thế giới bên ngoài đi qua hệ điều hành, hệ điều hành có thể được tận dụng để trích xuất thông tin như vậy. Công cụ theo dõi hệ thống có thể giám sát hoạt động mạng, truy cập tệp, truy cập registry, v.v ...ngoài ra còn có các công cụ để lộ một chương trình sử dụng các đối tượng hệ điều hành như mutexes, pipes, events, vân vân. Nhiều công cụ này sẽ được thảo luận trong Chương 4 và trong suốt cuốn sách này.

 **trình tháo gỡ**

 - Như tôi đã mô tả ở trên, Disassemblers là các chương trình thực hiện nhị phân thực thi của chương trình như là đầu vào và tạo các tệp văn bản có chứa mã ngôn ngữ lắp ráp cho toàn bộ chương trình hoặc các phần của nó.Đây là một quá trình tương đối đơn giản xem rằng mã ngôn ngữ lắp ráp chỉ đơn giản là bản đồ văn bản của mã đối tượng. Tháo gỡ là một quá trình xử lý cụ thể, Nhưng một số trình tháo gỡ hỗ trợ nhiều cấu trúc CPU. Một bộ phận phân tách chất lượng cao là một thành phần quan trọng trong bộ công cụ của người đảo ngược, nhưng một số người đảo ngược lại thích sử dụng các bộ phận tháo lắp lắp sẵn được nhúng trong trình gỡ rối mức thấp nhất định.

 **trình gỡ lỗi**

 - Nếu bạn đã từng cố gắng thậm chí cả việc phát triển phần mềm đơn giản nhất, bạn có thể đã sử dụng trình gỡ lỗi. Ý tưởng cơ bản đằng sau một trình gỡ rối là các lập trình viên có thể không thực sự hình dung mọi thứ mà chương trình của họ có thể làm. Các chương trình thường là quá phức tạp để con người thực sự tiên đoán mọi kết quả có thể xảy đến. Trình gỡ lỗi là một chương trình cho phép các nhà phát triển phần mềm quan sát chương trình của họ trong khi nó đang chạy. Hai tính năng cơ bản nhất trong trình sửa lỗi là khả năng đặt các điểm ngắt và khả năng theo dõi qua mã.

 - Breakpoints cho phép người dùng chọn một chức năng nhất định hoặc đường mã bất kỳ nơi nào trong chương trình và hướng dẫn trình gỡ lỗi để tạm dừng chương trình thực hiện đạt tới dòng đó. Khi chương trình đạt đến điểm ngắt, trình gỡ lỗi dừng lại (nghỉ) và hiển thị trạng thái hiện tại của chương trình. Tại thời điểm đó, có thể hoặc là giải phóng trình gỡ lỗi và chương trình sẽ tiếp tục chạy hoặc để bắt đầu truy tìm thông qua chương trình.

 - Trình gỡ lỗi cho phép người dùng theo dõi qua một chương trình trong khi nó đang chạy (điều này còn được gọi là bước đơn). Tracing có nghĩa là chương trình thực thi một dòng mã và đóng băng, cho phép người dùng quan sát hoặc thậm chí thay đổi trạng thái của chương trình. Sau đó người dùng có thể thực hiện dòng tiếp theo và lặp lại quá trình. Điều này cho phép các nhà phát triển để xem luồng chính xác của một chương trình ở một tốc độ phù hợp hơn cho sự hiểu biết của con người, mà khoảng chậm hơn một tỷ lần so với tốc độ chương trình thường chạy. 

 - Bằng cách cài đặt các điểm ngắt và truy tìm qua các chương trình, các nhà phát triển có thể xem một chương trình chặt chẽ vì nó thực hiện một đoạn mã khi có vấn đề và cố gắng xác định nguồn gốc của vấn đề. Bởi vì các nhà phát triển có quyền truy cập vào mã nguồn của chương trình của họ, các trình gỡ rối trình bày chương trình dưới dạng mã nguồn và cho phép các nhà phát triển đặt các điểm ngắt và theo dõi các đường nguồn mặc dù trình gỡ rối thực sự làm việc với mã máy bên dưới.
 - Đối với người đảo ngược, trình gỡ rối gần như quan trọng như đối với nhà phát triển phần mềm, nhưng vì lý do khác nhau. Đầu tiên và trước hết, người đảo ngược sử dụng trình gỡ lỗi trong chế độ tháo gỡ. Trong chế độ tháo gỡ, một trình sửa lỗi sử dụng một trình gỡ rối được tích hợp để tháo rời mã đối tượng khi đang chạy. Reversers có thể đi qua mã tháo rời và chủ yếu là "theo dõi" CPU khi nó chạy chương trình một hướng dẫn cùng một lúc. Cũng giống như việc gỡ lỗi cấp nguồn được thực hiện bởi các nhà phát triển phần mềm, người đảo ngược có thể cài đặt các điểm ngắt tại các địa điểm quan tâm đến mã đã tháo rời và sau đó kiểm tra trạng thái của chương trình. Đối với một số nhiệm vụ đảo chiều, điều duy nhất bạn sẽ cần là một trình gỡ lỗi tốt với khả năng tháo gỡ cài sẵn tốt. Có thể bước qua mã và xem như nó được thực hiện thực sự là một yếu tố vô giá trong quá trình đảo chiều


 **bộ biên dịch phục hồi**

 - Trình biên dịch lại là bước tiếp theo từ những trình tháo dỡ. Trình biên dịch sẽ lấy tệp tin nhị phân thực thi và cố gắng tạo ra mã ngôn ngữ cấp cao có thể đọc được từ nó.Ý tưởng là để thử đảo ngược quá trình biên dịch, Để có được các tập tin nguồn gốc hoặc một cái gì đó tương tự như nó. Trên phần lớn các nền tảng, sự phục hồi thực tế của mã nguồn gốc là không thực sự có thể. Có nhiều yếu tố quan trọng trong hầu hết các ngôn ngữ cấp cao mà chỉ cần bỏ qua trong quá trình biên dịch là không thể phục hồi. Tuy nhiên, trình biên dịch lại là công cụ mạnh mẽ trong một số tình huống và môi trường có thể tái tạo lại một mã nguồn dễ đọc được từ một chương trình nhị phân. Chương 13 thảo luận về quá trình phân hủy và những hạn chế của nó, và chỉ ra mức độ hiệu quả của nó.

 **khả năng tương tác **

 - Bắt hai chương trình để giao tiếp và tương tác không bao giờ là một nhiệm vụ dễ dàng. Ngay cả trong một sản phẩm được phát triển bởi một nhóm người, có những vấn đề liên quan đến giao diện thường xảy ra khi cố gắng thu được các thành phần riêng lẻ để tương tác. Các giao diện phần mềm rất phức tạp và các chương trình rất nhạy cảm mà những thứ này hiếm khi hoạt động đúng với nỗ lực đầu tiên. Nó chỉ là bản chất của công nghệ. Khi một nhà phát triển phần mềm muốn phát triển phần mềm giao tiếp với một thành phần được phát triển bởi một công ty khác, có một lượng lớn thông tin mà bên kia phải tiết lộ về các giao diện này. 

 - Một nền tảng phần mềm là bất kỳ chương trình hoặc thiết bị phần cứng nào mà các chương trình có thể chạy trên đầu nó. Ví dụ, cả Microsoft Windows và Sony Playstation đều là nền tảng phần mềm. Đối với nhà phát triển nền tảng phần mềm, quyết định có nên công khai hay không công khai các chi tiết của giao diện phần mềm của nền tảng đó là một trong những vấn đề quan trọng. Một mặt, lộ giao diện phần mềm có nghĩa là các nhà phát triển khác sẽ có thể phát triển phần mềm chạy trên nền tảng đó. Điều này có thể thúc đẩy doanh số bán hàng của nền tảng lên, nhưng nhà cung cấp cũng có thể cung cấp phần mềm của họ chạy trên nền tảng đó. Các giao diện phần mềmcông khai cũng sẽ tạo ra sự cạnh tranh mới cho các ứng dụng riêng của nhà cung cấp. Các khía cạnh pháp lý khác nhau ảnh hưởng đến loại kỹ thuật đảo ngược này như luật bản quyền, bảo vệ bí mật thương mại và bằng sáng chế được thảo luận trong các phần sau.

> Vào năm 1990, Sega Enterprises, một công ty game nổi tiếng của Nhật Bản, đã phát hành hệ thống chơi game Genesis. Các giao diện lập trình của Genesis đã không được công khai. Ý tưởng là cho Sega và các công ty con được cấp phép của họ là để  được các nhà phát triển duy nhất của trò chơi cho giao diện điều khiển. Accolade, một nhà phát triển trò chơi ở California, đã quan tâm đến việc phát triển các trò chơi mới cho Sega Genesis và chuyển một số trò chơi hiện tại của họ sang nền tảng Genesis. Accolade đã khám phá ra cách lựa chọn trở thành người được cấp phép Sega, nhưng nhanh chóng từ bỏ ý tưởng này bởi vì Sega yêu cầu tất cả các trò chơi được sản xuất độc quyền cho bàn điều khiển Genesis.. Thay vì trở thành người được cấp phép của Sega, Accolade đã quyết định sử dụng kỹ thuật đảo ngược để có được các chi tiết cần thiết để đưa trò chơi của họ tới nền tảng Genesis. Giải thưởng cải tiến các phần của bảng điều khiển Genesis và một số kỹ sư của Accelade và Sega sau đó đã sử dụng thông tin thu thập được trong các phiên làm việc revese để tạo ra một tài liệu mô tả các phát hiện của họ. Tài liệu nội bộ này về bản chất là thiếu tài liệu mô tả cách phát triển các trò chơi cho giao diện điều khiển Sega Genesis. Accolade đã phát triển thành công và bán được một số trò chơi cho nền tảng Genesis, và vào tháng 10 năm 1991 đã bị Sega cáo buộc vì vi phạm bản quyền. Đơn kiện chính của Sega là các bản sao của Accolade trong quá trình đảo ngược kỹ thuật (được gọi là "sao chép trung gian") vi phạm luật bản quyền. Cuối cùng, tòa án phán quyết về việc ủng hộ  Accolade vì các trò chơi của Accolade không thực sự chứa bất kỳ mã nào của Sega và vì lợi ích công cộng từ công việc của Accolade (bằng cách đưa ra cạnh tranh bổ sung trên thị trường). Đây là một mốc quan trọng trong lịch sử pháp lý của kỹ thuật đảo ngược bởi vì trong phán quyết này, tòa án đã cho phép kỹ thuật đảo ngược với mục đích tương hợp.

**sự cạnh tranh**

- Khi được sử dụng cho khả năng tương tác, kỹ thuật đảo ngược rõ ràng mang lại lợi ích cho xã hội bởi vì nó đơn giản hoá (hoặc cho phép) sự phát triển của các công nghệ mới và được cải tiến. Khi kỹ thuật đảo ngược được sử dụng trong sự phát triển của các sản phẩm cạnh tranh, tình huống phức tạp hơn một chút. Những người phản đối kỹ thuật đảo ngược thường tuyên bố rằng việc đảo ngược làm dấy lên sự đổi mới bởi vì các nhà phát triển các công nghệ mới có ít động lực đầu tư vào nghiên cứu và phát triển nếu công nghệ của họ có thể dễ dàng "đánh cắp" bởi các đối thủ cạnh tranh thông qua kỹ thuật đảo ngược. Điều này mang lại cho chúng ta những câu hỏi về những gì chính xác cấu thành kỹ thuật đảo ngược cho mục đích phát triển một sản phẩm cạnh tranh.

- Ví dụ cực đoan nhất là trực tiếp lấy cắp phân đoạn mã khỏi sản phẩm của đối thủ cạnh tranh và nhúng chúng vào của riêng bạn. Đây là một vi phạm rõ ràng về luật bản quyền và rất dễ chứng minh. Một ví dụ phức tạp hơn là áp dụng một số loại quá trình giải mã cho một chương trình và biên dịch lại đầu ra của nó theo cách tạo ra một nhị phân với chức năng giống nhau nhưng với mã dường như khác nhau. Điều này cũng tương tự như ví dụ trước, ngoại trừ trong trường hợp này sẽ rất khó khăn để chứng minh rằng mã đã thực sự bị đánh cắp..

- Cuối cùng, kỹ thuật đảo ngược (và đạo đức) có liên quan hơn trong tình huống sản phẩm cạnh tranh là nơi kỹ thuật đảo ngược chỉ được áp dụng cho các bộ phận nhỏ của sản phẩm và chỉ được sử dụng cho việc thu thập thông tin chứ không phải là mã. Trong những trường hợp này hầu hết sản phẩm được phát triển độc lập mà không cần sử dụng kỹ thuật đảo ngược và chỉ những khu vực phức tạp nhất và độc đáo nhất của sản phẩm của đối thủ cạnh tranh được thiết kế lại và tái sử dụng trong sản phẩm mới

### phần mềm cấp thấp.

 - Chương này cung cấp phần giới thiệu về phần mềm mức thấp, đây là một khía cạnh quan trọng của lĩnh vực kỹ thuật đảo ngược. Phần mềm cấp thấp là một cái tên chung cho các khía cạnh cơ sở hạ tầng của thế giới phần mềm. Bởi vì các khía cạnh cấp thấp của phần mềm thường là những thứ duy nhất có thể nhìn thấy đối với chúng tôi như là các kỹ sư đảo ngược, chúng tôi phải phát triển sự hiểu biết vững chắc về các lớp này cùng nhau tạo thành các phần mềm cấp thấp.

 - Chương này mở ra với tổng quan rất ngắn gọn về góc nhìn cấp cao của phần mềm mà mọi nhà phát triển phần mềm đã tiếp xúc. Sau đó chúng tôi tiến hành giới thiệu về phần mềm cấp thấp và chứng minh khái niệm nền tảng cấp cao như thế nào trên bản đồ cấp thấp . Tiếp theo là phần giới thiệu về ngôn ngữ lắp ráp, đây là yếu tố chính trong quá trình đảo ngược và một phần quan trọng của cuốn sách này. Cuối cùng, chúng tôi giới thiệu một số chủ đề phụ trợ cấp thấp có thể hỗ trợ hiểu phần mềm ở mức độ thấp: trình biên dịch và môi trường thực hiện phần mềm. 

 - Nếu bạn là một nhà phát triển phần mềm có kinh nghiệm, thì các bộ phận của chương này có vẻ như tầm thường, đặc biệt là các quan điểm cấp cao trong phần đầu của chương này. Nếu đúng như vậy, bạn nên bắt đầu đọc từ phần "Low-Level Perspectives" ở phần sau của chương này, cung cấp quan điểm cấp thấp về các khái niệm phát triển phần mềm quen thuộc. Nếu đúng như vậy, bạn nên bắt đầu đọc từ phần "Low-Level Perspectives" ở phần sau của chương này, cung cấp quan điểm cấp thấp về các khái niệm phát triển phần mềm quen thuộc

#### khía cạnh phần mềm cấp cao

 - Chúng ta hãy xem lại một số khái niệm phát triển phần mềm cơ bản khi chúng được nhìn từ quan điểm của các kỹ sư phần mềm thông thường. Mặc dù quan điểm này hoàn toàn khác so với quan điểm của chúng tôi trong khi đảo chiều, nhưng vẫn có ý để xem lại các chủ đề này chỉ để đảm bảo chúng luôn mới mẻ trong tâm trí của bạn trước khi tham gia thảo luận về phần mềm cấp thấp.

 -  Các phần sau đây cung cấp một cái nhìn khái quát về các khái niệm cơ bản của kỹ thuật phần mềm như cấu trúc chương trình (các thủ tục, các đối tượng, và các loại tương tự), các khái niệm quản lý dữ liệu (như các cấu trúc dữ liệu điển hình, vai trò của các biến vv) và cấu trúc kiểm soát luồng cơ bản . Nếu bạn là một nhà phát triển phần mềm chuyên nghiệp và cảm thấy rằng các chủ đề này hoàn toàn rõ ràng đối với bạn, hãy bỏ qua phần "Low Level Perspectives "sau trong chương này. Trong bất kỳ trường hợp nào, xin lưu ý rằng đây là một tổng quan cực kỳ ngắn gọn của vật liệu có thể lấp đầy một vài cuốn sách. Phần này không phải là phần giới thiệu về phát triển phần mềm - phần giới thiệu như vậy nằm ngoài phạm vi của cuốn sách này

 **Cấu trúc chương trình**

 - Khi tôi còn là một đứa trẻ, các nỗ lực lập trình đầu tiên của tôi thường là các đoạn mã BASIC dài mà chỉ chạy theo tuần và có các lệnh goto thường xuyên đi qua lại giữa các phần khác nhau của chương trình. Đó là trước khi tôi đã khám phá được phép lạ của cấu trúc chương trình. Cấu trúc chương trình là điều làm cho phần mềm, một điều vốn có lớn và phức tạp vốn có thể quản lý được bởi con người. Chúng tôi phá vỡchương trình lớn thành các khối nhỏ, trong đó mỗi đoạn đại diện cho một "đơn vị" trong chương trình để thuận tiện tạo ra một hình ảnh tinh thần của chương trình trong tâm trí của chúng tôi. Quy trình tương tự diễn ra trong quá trình kỹ thuật đảo ngược. Người dịch ngược phải cố gắng và tái dựng bản đồ này của các thành phần khác nhau mà cùng nhau tạo nên một chương trình. Thật không may, đó không phải là điều luôn luôn dễ dàng.

 - Vấn đề là các máy không thực sự cần cấu trúc chương trình nhiều như chúng ta làm. Con người chúng ta không thể đối phó với khái niệm làm việc và hiểu biết một điều phức tạp-đối tượng lớn hoặc các khái niệm cần phải được chia thành các khối mới quản lý được. Những khối này rất tốt cho việc phân chia công việc giữa nhiều người và cũng tạo ra sự phân chia tâm trí của công việc trong tâm trí của một người. Đây thực sự là khái niệm khái quát về tư duy của con người-khi phải đối mặt với các nhiệm vụ lớn, chúng ta tự nhiên cố gắng phá vỡ chúng thành một nhóm nhỏ các tác vụ để cùng nhau tạo thành toàn bộ. Mặt khác, máy móc thường có nhu cầu mâu thuẫn để loại bỏ một số các yếu tố cấu trúc này. Ví dụ, suy nghĩ về cách quá trình biên dịch và liên kết một chương trình loại bỏ cấu trúc chương trình: các tệp nguồn cá nhân và các thư viện đều được liên kết thành một tệp thực thi duy nhất, nhiều ranh giới của chức năng được loại bỏ thông qua việc lồng vào và chỉ đơn giản là dán vào mã gọi chúng. Máy này loại bỏ các chi tiết cấu trúc dự phòng mà không cần thiết cho việc chạy mã hiệu quả. Tất cả các biến đổi này ảnh hưởng đến quá trình đảo ngược và làm cho nó một phần khó khăn hơn. Tôi sẽ làm việc với quá trình tái thiết cấu trúc của một chương trình trong các dự án đảo ngược trong suốt cuốn sách này.

 - Làm thế nào để các nhà phát triển phần mềm chia nhỏ phần mềm thành các khối có thể quản lý được?. Ý tưởng chung là xem chương trình như là một tập hợp các hộp đen riêng biệt có trách nhiệm cho các nhiệm vụ rất cụ thể và (hy vọng) xác định chính xác. Ý tưởng là ai đó thiết kế và thực hiện một hộp đen, kiểm tra nó và xác nhận rằng nó hoạt động, và sau đó tích hợp nó với các thành phần khác trong hệ thống. Một chương trình có thể được xem như là một tập hợp lớn các hộp đen tương tác với nhau. Các ngôn ngữ lập trình khác nhau và các nền tảng phát triển tiếp cận các khái niệm này củng khác nhau, nhưng ý tưởng chung hầu như luôn giống nhau. 

 - Tương tự như vậy, khi một ứng dụng đang được thiết kế, nó thường được chia thành các hộp đen ảo mà mỗi người chịu trách nhiệm cho một đoạn của ứng dụng. Ví dụ, trong trình xử lý văn bản, bạn có thể xem thành phần soạn thảo văn bản như một hộp và thành phần kiểm tra lỗi chính tả như là một hộp khác. Quá trình này được gọi là đóng gói vì mỗi thành phần hộp đóng gói chức năng nhất định và chỉ cần làm cho nó có sẵn cho bất cứ ai cần nó, mà không tiết lộ chi tiết không cần thiết về việc thực hiện nội bộ của thành phần. Hộp thành phần thường được phát triển bởi những người khác nhau hoặc thậm chí bởi các nhóm khác nhau, nhưng họ vẫn phải có khả năng tương tác với nhau. Các hộp có kích thước khác nhau: Một số hộp thực hiện toàn bộ các tính năng của ứng dụng (ví dụ như ví dụ về kiểm tra lỗi chính tả trước đó), trong khi các tệp khác lại đại diện cho các chức năng nhỏ hơn và nguyên thủy hơn như chức năng sắp xếp và các chức năng quản lý dữ liệu cấp thấp khác. Các hộp nhỏ hơn này thường được làm cho chung chung, có nghĩa là chúng có thể được sử dụng ở bất kỳ nơi nào trong chương trình, nơi mà các chức năng cụ thể mà chúng cung cấp là bắt buộc. 

 - Phát triển một sản phẩm mạnh mẽ và đáng tin cậy chủ yếu dựa trên hai yếu tố: mỗi hộp thành phần được thực hiện tốt và thực hiện nhiệm vụ một cách đáng tin cậy, và mỗi hộp đều có một giao diện được xác định rõ ràng để giao tiếp với thế giới bên ngoài.

 - Trong hầu hết các kịch bản đảo ngược, bước đầu tiên là xác định cấu trúc thành phần của ứng dụng và trách nhiệm chính xác của mỗi thành phần. Từ đó, người ta thường chọn một thành phần quan trọng và phát triển thành các chi tiết về việc thực hiện nó. Các phần sau mô tả các công cụ kỹ thuật khác nhau có sẵn cho các nhà phát triển phần mềm để triển khai kiểu đóng gói mức thành phần này trong mã. Chúng tôi bắt đầu với các thành phần lớn, chẳng hạn như các mô đun tĩnh và động, và tiến hành các đơn vị nhỏ hơn như các thủ tục và các đối tượng.

 **Modules**

 - Khối xây dựng lớn nhất cho một chương trình là mô đun . Các mô-đun chỉ đơn giản là các tệp nhị phân chứa các vùng riêng biệt của chương trình thực thi (về cơ bản chính là các hộp thành phần từ cuộc thảo luận trước đây của chúng tôi). Có hai loại mô đun cơ bản có thể kết hợp với nhau để tạo ra một chương trình: các thư viện tĩnh và các thư viện động.

 **Thư viện tĩnh:** Thư viện tĩnh tạo thành một nhóm các tệp mã nguồn được xây dựng cùng nhau và đại diện cho một thành phần nhất định của một chương trình. Về mặt logic, các thư viện tĩnh thường đại diện cho một tính năng hoặc một khu vực có chức năng trong chương trình . Thông thường, một thư viện tĩnh không phải là một phần không tách rời của sản phẩm đang được phát triển mà là một thư viện bên thứ ba, bổ sung thêm chức năng nào đó vào nó. Thư viện tĩnh được thêm vào một chương trình trong khi nó đang được xây dựng, và chúng trở thành một phần không thể tách rời của chương trình nhị phân. Chúng rất khó nhận ra và cô lập khi chúng ta nhìn vào chương trình từ góc độ cấp thấp trong khi đảo chiều.

 - **Thư viện động:** Thư viện động (được gọi là Thư viện liên kết động, hoặc DLL trong Windows) tương tự như các thư viện tĩnh, ngoại trừ chúng không được nhúng vào chương trình và chúng vẫn ở trong một tệp riêng biệt, ngay cả khi chương trình được chuyển đến người dùng cuối. Thư viện động cho phép nâng cấp các thành phần riêng lẻ trong một chương trình mà không cần cập nhật toàn bộ chương trình. Miễn là giao diện nó xuất ra vẫn không đổi, một thư viện có thể (ít nhất là về mặt lý thuyết) được thay thế hoàn toàn - mà không cần nâng cấp bất kỳ thành phần nào khác trong chương trình. Thư viện được nâng cấp thường chứa mã được cải thiện, hoặc thậm chí là các chức năng hoàn toàn khác nhau thông qua cùng một giao diện. Các thư viện động rất dễ phát hiện trong khi đảo chiều, và các giao diện giữa chúng thường đơn giản hóa quá trình đảo ngược vì chúng cung cấp những gợi ý hữu ích về kiến trúc của chương trình.

#### cấu trúc chung của mã 

 - Có hai cấu trúc cấp mã cơ bản được coi là các khối xây dựng cơ bản nhất cho một chương trình. Đó là các thủ tục và đối tượng, Xét về cấu trúc mã, thủ tục là đơn vị cơ bản nhất trong phần mềm. Một thủ tục là một đoạn mã, thường với một mục đích rõ ràng, có thể được viện dẫn bởi các khu vực khác trong chương trình. Các thủ tục có thể tùy ý nhận dữ liệu đầu vào từ người gọi và trả lại dữ liệu cho người gọi. Thủ tục là hình thức đóng gói được sử dụng phổ biến nhất trong bất kỳ ngôn ngữ lập trình nào.

 - Bước nhảy vọt hợp lý tiếp theo làm thay thế thủ tục là chia chương trình thành các đối tượng. Thiết kế một chương trình bằng cách sử dụng các đối tượng là một quá trình hoàn toàn khác so với quá trình thiết kế một chương trình dựa trên thủ tục thông thường. Quá trình này được gọi là thiết kế theo hướng đối tượng (OOD) và được nhiều người cho là cách tiếp cận phổ biến và hiệu quả nhất đối với thiết kế phần mềm hiện đang có sẵn. Phương pháp OOD định nghĩa một đối tượng như một thành phần chương trình có cả dữ liệu và mã kết hợp với nó. Mã có thể là một tập các thủ tục có liên quan đến đối tượng và có thể thao tác dữ liệu của nó. Dữ liệu là một phần của đối tượng và thường là riêng tư, có nghĩa là nó chỉ có thể được truy cập bằng mã đối tượng chứ không phải từ thế giới bên ngoài. Điều này đơn giản hoá các quy trình thiết kế, bởi vì các nhà phát triển buộc phải đối xử với các đối tượng như các thực thể bị cô lập hoàn toàn chỉ có thể được truy cập thông qua các giao diện được xác định rõ.  Những giao diện này thường bao gồm một tập hợp các thủ tục liên quan đến đối tượng. Các thủ tục này có thể được định nghĩa là các thủ tục truy cập công cộng, và được gọi chủ yếu bởi các khách hàng của đối tượng. Khách hàng là các thành phần khác trong chương trình đòi hỏi các dịch vụ của đối tượng nhưng không quan tâm đến bất kỳ chi tiết thực hiện của nó. Trong hầu hết các chương trình, khách hàng là những đối tượng mà chỉ cần các dịch vụ của các đối tượng khác.

 - Ngoài việc phân chia một chương trình thành các đối tượng, hầu hết các ngôn ngữ lập trình hướng đối tượng cung cấp một tính năng bổ sung được gọi là kế thừa. Thừa kế cho phép các nhà thiết kế thiết lập một kiểu đối tượng chung và thực hiện nhiều triển khai cụ thể của loại đó cung cấp một số chức năng khác nhau. Ý tưởng là giao diện vẫn giữ nguyên, do đó khách hàng sử dụng đối tượng không phải biết bất cứ điều gì về loại đối tượng cụ thể mà nó đang xử lý - chỉ cần biết loại cơ sở mà từ đó đối tượng đó xuất phát. Khái niệm này được thực hiện bằng cách khai báo một đối tượng cơ sở, bao gồm một khai báo của một giao diện chung chung được sử dụng bởi mọi đối tượng kế thừa từ đối tượng cơ sở đó. Các đối tượng cơ bản thường là các khai báo rỗng có ít hoặc không có chức năng thực tế. Để thêm một thực hiện thực tế của kiểu đối tượng, một đối tượng khác được khai báo, thừa hưởng từ đối tượng cơ sở và chứa các thực hiện thực tế của các thủ tục giao diện, cùng với bất kỳ mã hỗ trợ hoặc các cấu trúc dữ liệu.Vẻ đẹp của hệ thống này là đối với một đối tượng cơ sở duy nhất có thể có nhiều đối tượng hậu duệ có thể thực hiện các chức năng hoàn toàn khác nhau, nhưng xuất khẩu cùng một giao diện. Khách hàng có thể sử dụng các đối tượng này mà không biết loại đối tượng cụ thể họ đang xử lý - họ chỉ biết loại đối tượng cơ sở. Khái niệm này được gọi là đa hình.

#### Quản lý dữ liệu
 
 - Một chương trình đề cập đến dữ liệu. Bất kỳ thao tác nào luôn đòi hỏi dữ liệu đầu vào, khoảng trống cho dữ liệu trung gian và cách gửi lại kết quả. Để xem một chương trình từ mức thấp và hiểu rõ điều gì đang xảy ra, bạn phải hiểu được dữ liệu như thế nào là phần mềm Low-Level được quản lý trong chương trình. Điều này đòi hỏi hai quan điểm: quan điểm cấp cao khi các nhà phát triển phần mềm xem và quan điểm cấp thấp được xem bởi người đảo ngược.

 - Các ngôn ngữ cấp cao có xu hướng cô lập các nhà phát triển phần mềm từ các chi tiết xung quanh quản lý dữ liệu ở cấp hệ thống. Các nhà phát triển thường chỉ nhận thức được luồng dữ liệu đơn giản được mô tả bởi ngôn ngữ cấp cao. Đương nhiên, hầu hết người đảo ngược quan tâm đến việc có được một cái nhìn của chương trình phù hợp với cái nhìn đơn giản hóa cấp cao càng sát càng tốt, Đó là bởi vì quan điểm cấp cao thường rất thân thiện với con người hơn quan điểm của máy. Thật không may, phần lớn các ngôn ngữ lập trình và các nền tảng phát triển phần mềm lấy hết  (hoặc làm hỏng) nhiều thông tin con người có thể đọc được từ các tệp nhị phân được vận chuyển đến người dùng cuối. Để có thể khôi phục lại một số hoặc tất cả thông tin luồng dữ liệu cấp cao đó từ một chương trình nhị phân, bạn phải hiểu cách thức các chương trình xem và xử lý dữ liệu từ quan điểm cấp cao của lập trình viên và mã máy tạo ở mức độ thấp. Các phần dưới đây đưa chúng ta qua tổng quan ngắn gọn về các cấu trúc dữ liệu cấp cao như các biến và các loại cấu trúc dữ liệu phổ biến nhất.

### biến 
 - Đối với nhà phát triển phần mềm, chìa khóa để quản lý và lưu trữ dữ liệu thường được đặt tên là các biến. Tất cả các ngôn ngữ cấp cao cung cấp cho các nhà phát triển các phương tiện để khai báo các biến ở phạm vi khác nhau và sử dụng chúng để lưu trữ thông tin. Ngôn ngữ lập trình cung cấp một số trừu tượng cho các biến này. Cấp mà các biến được xác định sẽ xác định phần nào của chương trình sẽ có thể truy cập vào nó, và cũng tại nơi nó sẽ được lưu trữ vật lý. Tên của các biến được đặt tên thường chỉ có liên quan trong quá trình biên dịch. Nhiều trình biên dịch hoàn toàn xóa tên của các biến từ chương trình gốc và xác định chúng bằng cách sử dụng địa chỉ của chúng trong bộ nhớ. Việc này có được thực hiện hay không tùy thuộc vào nền tảng đích mà chương trình đang được xây dựng.

 - Các cấu trúc dữ liệu do người dùng xác định:

 Các cấu trúc dữ liệu do người dùng định nghĩa là các cấu trúc đơn giản thể hiện một nhóm các trường dữ liệu, mỗi loại có một kiểu riêng. Ý tưởng là các trường này đều có liên quan bằng cách nào đó, đó là lý do tại sao chương trình lưu trữ và xử lý chúng như một đơn vị duy nhất. Các kiểu dữ liệu của các trường cụ thể bên trong một cấu trúc dữ liệu có thể là các kiểu dữ liệu đơn giản như số nguyên hoặc các con trỏ hoặc chúng có thể là các cấu trúc dữ liệu khác.

 - Trong khi đảo chiều, bạn sẽ gặp nhiều cấu trúc dữ liệu do người dùng định nghĩa. Xác định đúng cấu trúc dữ liệu và giải mã nội dung của chúng là rất quan trọng để đạt được sự hiểu biết của chương trình. Chìa khóa để thực hiện điều này là để từng bước ghi lại mọi chi tiết nhỏ bé phát hiện ra về nó cho đến khi bạn có một sự hiểu biết đầy đủ về từng trường. Quá trình này sẽ được trình bày trong các chương biến đổi trong phần thứ hai của cuốn sách này.

 **danh sách**

 - Khác với cấu trúc dữ liệu người dùng định nghĩa, các chương trình thường sử dụng nhiều cấu trúc dữ liệu chung để tổ chức dữ liệu. Hầu hết các cấu trúc dữ liệu chung này đại diện cho các danh sách các mục (trong đó mỗi mục có thể thuộc bất kỳ loại nào, từ một số nguyên đơn giản đến một cấu trúc dữ liệu phức tạp do người dùng định nghĩa). Danh sách chỉ đơn giản là một nhóm các mục dữ liệu chia sẻ cùng một loại dữ liệu và các quan điểm của chương trình thuộc về cùng một nhóm. Trong hầu hết các trường hợp, mục nhập danh sách cá nhân chứa thông tin duy nhất trong khi chia sẻ bố cục dữ liệu chung. Ví dụ bao gồm các danh sách như danh sách các địa chỉ liên lạc trong chương trình tổ chức hoặc danh sách thư điện tử trong một chương trình e-mail. Đó là những danh sách người sử dụng nhìn thấy được, nhưng hầu hết các chương trình cũng sẽ duy trì một loạt các danh sách người dùng vô hình để quản lý những thứ như các khu vực trong bộ nhớ hiện đang hoạt động, các tập tin hiện đang mở để truy cập, và tương tự vậy. 

 - Cách thức trong danh sách được đặt ra trong bộ nhớ là một quyết định thiết kế quan trọng cho các kỹ sư phần mềm và thường phụ thuộc vào nội dung của các mục và các loại hoạt động được thực hiện trong danh sách. Số lượng dự kiến của các mục cũng là một yếu tố quyết định trong việc lựa chọn định dạng của danh sách. Ví dụ: các danh sách được mong đợi có hàng ngàn hoặc hàng triệu mục có thể được đặt ra khác với danh sách chỉ có thể phát triển đến một vài mục. Ngoài ra, trong một số danh sách thứ tự của các mục là rất quan trọng, và các mục mới được liên tục bổ sung và loại bỏ khỏi các vị trí cụ thể ở giữa danh sách. Các danh sách khác không nhạy cảm với vị trí cụ thể của từng mục. Một tiêu chí khác là khả năng tìm kiếm các mục một cách hiệu quả và nhanh chóng tiếp cận chúng. Sau đây là một cuộc thảo luận ngắn gọn về các danh sách chung được tìm thấy trong chương trình trung bình:

 ** mảng** 
  - Mảng là bố cục danh sách cơ bản nhất và trực quan-các mục được đặt theo thứ tự trong một bộ nhớ. Các mục được tham chiếu bởi mã bằng cách sử dụng số chỉ mục của chúng, chỉ là số mục từ đầu danh sách đến mục được đề cập. Ngoài ra còn có mảng đa chiều, có thể được hình dung như mảng đa cấp. Ví dụ, một mảng hai chiều có thể được hình dung như một bảng đơn giản với các hàng và cột, nơi mỗi tham chiếu đến bảng yêu cầu sử dụng hai chỉ thị vị trí: hàng và cột. Nhược điểm đáng kể nhất của mảng là sự khó khăn trong việc thêm và xóa các mục ở giữa danh sách. Làm như vậy yêu cầu rằng nửa sau của mảng (bất kỳ mục nào đến sau mục chúng tôi thêm hoặc xóa) được sao chép để tạo chỗ trống cho mục mới hoặc loại bỏ khe trống rỗng trước đó đã chiếm bởi một mục. Với danh sách rất lớn, đây có thể là một hoạt động vô cùng hiệu quả.

**danh sách liên kết **

 - Trong một danh sách liên kết, mỗi mục được cho không gian bộ nhớ của riêng mình và có thể được đặt bất cứ nơi nào trong bộ nhớ. Mỗi mục lưu trữ địa chỉ bộ nhớ của mục tiếp theo (một liên kết), và đôi khi cũng là một liên kết đến các mục trước đó. Sự sắp xếp này có thêm tính linh hoạt trong việc hỗ trợ bổ sung nhanh chóng hoặc xóa bỏ một mục vì không cần phải sao chép bộ nhớ. Để thêm hoặc xóa các mục trong một danh sách liên kết, các liên kết trong các mục bao quanh mục đang được thêm vào hoặc xoá phải được thay đổi để phản ánh thứ tự mới của các mục. Danh sách liên kết giải quyết sự yếu kém của các mảng liên quan đến tính không hiệu quả khi thêm và xóa các mục bằng cách không đặt các mục liên tiếp trong bộ nhớ. Tất nhiên, danh sách liên kết cũng có những điểm yếu của nó. Bởi vì các mục được phân tán ngẫu nhiên trong suốt bộ nhớ, có thể không có truy cập nhanh vào các mục riêng lẻ dựa trên chỉ mục của chúng. Ngoài ra, danh sách liên kết kém hiệu quả hơn so với mảng sử dụng bộ nhớ vì mỗi mục trong danh sách phải có một hoặc hai liên kết con trỏ, sử dụng bộ nhớ quý giá.

**cây **

- Một cây tương tự như một danh sách liên kết trong đó bộ nhớ được phân bổ riêng cho mỗi mục trong danh sách. Sự khác biệt là trong sắp xếp hợp lý của các mục: Trong cấu trúc cây, các mục được sắp xếp theo thứ bậc, làm đơn giản hóa quá trình tìm kiếm một mục. Mục gốc biểu thị một điểm trung bình trong danh sách, và chứa các liên kết đến hai nửa của cây (đó là các nhánh chính): một nhánh liên kết tới các mục có giá trị thấp hơn, trong khi nhánh khác liên kết đến các mục có giá trị cao hơn. Cũng giống như các mục gốc, mỗi mục trong các cấp thấp hơn của hệ thống phân cấp cũng có hai liên kết đến các nút thấp hơn (trừ khi nó là mục thấp nhất trong hệ thống phân cấp). Bố cục này đơn giản hoá quá trình tìm kiếm nhị phân, trong đó mỗi lần lặp lại một lần loại bỏ một nửa danh sách trong đó nó được biết rằng mục không có mặt. Với một tìm kiếm nhị phân, số lần lặp lại yêu cầu rất thấp vì mỗi lần lặp lại danh sách sẽ ngắn hơn 50%.

#### điều khiển luồng 

 - Để thực sự hiểu được một chương trình trong khi đảo ngược, bạn sẽ hầu như luôn luôn phải giải mã các câu lệnh điều khiển dòng chảy và cố gắng tái tạo lại logic đằng sau những câu lệnh đó. các câu lệnh Kiểm soát dòng chảy là các câu lệnh ảnh hưởng đến dòng chảy của chương trình dựa trên các giá trị và điều kiện nhất định. Trong các ngôn ngữ cấp cao, các câu lệnh kiểm soát dòng chảy đến dưới dạng các khối điều kiện cơ bản và các vòng lặp, được chuyển thành các câu lệnh điều khiển mức thấp của trình biên dịch. Đây là một tổng quan ngắn gọn về cấu trúc dòng chảy điều khiển cơ bản cấp cao:

**khối lệnh điều kiện**

 - Khối mã có điều kiện được thực hiện trong hầu hết các ngôn ngữ lập trình sử dụng câu lệnh ``if``. Chúng cho phép chỉ định một hoặc nhiều điều kiện để kiểm soát xem một khối mã được thực thi hay không.

** chuyển khối **

 - Các khối chuyển đổi (thường được gọi là các điều kiện n-way) thường lấy giá trị đầu vào và xác định nhiều khối mã có thể được thực hiện cho các giá trị đầu vào khác nhau. Một hoặc nhiều giá trị được gán cho mỗi khối mã, và chương trình nhảy tới khối mã chính xác trong thời gian chạy dựa trên giá trị đầu vào. Trình biên dịch thực hiện tính năng này bằng cách tạo ra mã nhận giá trị đầu vào và tìm kiếm khối mã chính xác để thực thi, thường là bằng cách tra cứu một bảng tra cứu có các con trỏ đến tất cả các khối mã khác nhau. 

 **Loops:** Các vòng lặp cho phép các chương trình thực hiện lặp đi lặp lại cùng một khối mã nhiều lần . Một vòng lặp thường quản lý một bộ đếm để  xác định số lần lặp đã thực hiện hoặc số lần lặp lại. Tất cả các vòng lặp bao gồm một số câu lệnh điều kiện xác định khi nào vòng lặp bị ngưng. Một cách khác để xem xét một vòng lặp là coi nó như một câu lệnh có điều kiện giống với một khối điều kiện, với sự khác biệt là khối điều kiện được thực hiện liên tục. Quá trình này bị ngắt khi điều kiện không còn thỏa mãn. 

### ngôn ngữ bậc cao (high-lever Language) 

 - Các ngôn ngữ cấp cao đã được tạo ra để cho phép các lập trình tạo ra phần mềm mà không phải lo lắng về nền tảng phần cứng cụ thể mà chương trình của họ sẽ chạy và không phải lo lắng về tất cả các loại chi tiết cấp thấp gây phiền nhiễu mà không có liên quan gì đến hầu hết các lập trình viên . hợp ngữ có lợi thế của nó, nhưng hầu như không thể tạo ra phần mềm lớn và phức tạp với một mình hợp ngữ. Ngôn ngữ cấp cao đã được tạo ra để cô lập các lập trình viên với máy tính và các chi tiết nhỏ bé của nó càng nhiều càng tốt

 - Vấn đề với ngôn ngữ cấp cao là có những nhu cầu khác nhau ở những người khác nhau và các lĩnh vực khác nhau trong ngành. Sự cân bằng chính giữa sự giản dị và tính linh hoạt. Tính đơn giản nghĩa là bạn có thể viết một chương trình tương đối ngắn mà thực hiện chính xác những gì bạn cần, mà không phải đối phó với nhiều chi tiết cấp độ máy không liên quan. Tính linh hoạt có nghĩa là không có bất cứ điều gì mà bạn không thể làm với ngôn ngữ. Các ngôn ngữ cấp cao thường nhằm mục đích tìm ra sự cân bằng phù hợp với hầu hết người dùng của họ. Một mặt nữa, có một số điều xảy ra ở cấp độ máy mà các lập trình viên không cần biết. Mặt khác, ẩn các khía cạnh nhất định của hệ thống có nghĩa là bạn mất khả năng làm những điều nhất định. Khi bạn đảo ngược một chương trình, bạn thường không còn lựa chọn nào khác ngoài việc bắt bạn bẩn tay và nhận ra nhiều chi tiết xảy ra ở cấp độ máy. Trong hầu hết các trường hợp, bạn sẽ được nhìn thấy những khía cạnh mơ hồ của hoạt động bên trong của một chương trình mà ngay cả những lập trình viên đã viết chúng cũng không biết. Thách thức là tìm hiểu thông tin này với sự hiểu biết đầy đủ về ngôn ngữ cấp cao được sử dụng và để cố gắng đạt được ước lượng gần đúng về những gì đã có trong mã nguồn gốc. Làm thế nào điều này được thực hiện phụ thuộc rất nhiều vào ngôn ngữ lập trình cụ thể được sử dụng để phát triển chương trình.

 - Từ quan điểm đảo chiều, điều quan trọng nhất về một ngôn ngữ lập trình cấp cao là nó mạnh mẽ như thế nào nó ẩn hoặc tóm tắt các máy tính cơ bản. Một số ngôn ngữ như C cung cấp một viễn cảnh tương đối thấp trên máy tính và tạo ra mã chạy trực tiếp trên bộ xử lý đích. Các ngôn ngữ khác như Java cung cấp một mức độ đáng kể sự tách biệt giữa các lập trình viên và bộ xử lý cơ bản. Các phần sau sẽ  thảo luận ngắn gọn các ngôn ngữ lập trình phổ biến nhất hiện nay

#### C

 - Ngôn ngữ lập trình C là một ngôn ngữ mức độ tương đối thấp với các ngôn ngữ bậc cao . C cung cấp hỗ trợ trực tiếp cho các con trỏ bộ nhớ và cho phép bạn thao tác chúng như bạn muốn. Mảng có thể được định nghĩa trong C, nhưng không có giới hạn kiểm tra bất cứ điều gì, vì vậy bạn có thể truy cập bất kỳ địa chỉ trong bộ nhớ mà bạn muốn. Mặt khác, C cung cấp hỗ trợ cho các tính năng cấp cao phổ biến được tìm thấy trong các ngôn ngữ cấp cao khác. Điều này bao gồm hỗ trợ cho các mảng và cấu trúc dữ liệu, khả năng dễ dàng thực hiện mã điều khiển luồng như mã điều kiện và các vòng lặp, và các mã khác.

 - C là một ngôn ngữ biên dịch, có nghĩa là để chạy chương trình, bạn phải chạy mã nguồn thông qua trình biên dịch tạo ra chương trình nhị phân trên nền tảng cụ thể. Những chương trình nhị phân này chứa mã máy trong ngôn ngữ tự nhiên của bộ xử lý đích. C cũng cung cấp sự hỗ trợ đa nền tảng. Để chạy một chương trình trên nhiều nền tảng, bạn phải biên dịch lại nó với một trình biên dịch hỗ trợ nền tảng đích cụ thể. 

 - Nhiều yếu tố đã góp phần vào thành công của C, nhưng có lẽ quan trọng nhất là thực tế là ngôn ngữ đã được phát triển đặc biệt cho mục đích viết hệ điều hành Unix. Các phiên bản hiện đại của Unix như hệ điều hành Linux vẫn được viết bằng C. Ngoài ra, phần quan trọng của hệ điều hành Microsoft Windows cũng được viết bằng C (với phần còn lại của các thành phần viết bằng C ++).

 - Một tính năng khác của C làm ảnh hưởng đến thành công thương mại của nó là hiệu năng cao. Bởi vì C mang lại cho bạn rất gần với máy, mã được viết bởi các lập trình viên gần như trực tiếp được dịch sang mã máy bởi trình biên dịch, với chi tiết thêm vào rất ít. Điều này có nghĩa là các chương trình viết bằng C thường có hiệu năng thời gian chạy rất cao.

 - Mã C là tương đối dễ dàng để đảo ngược bởi vì nó là khá tương tự như mã máy. Khi đảo ngược, người ta cố gắng đọc mã máy và xây dựng lại mã nguồn gốc càng sát càng tốt (mặc dù đôi khi đơn giản là hiểu được mã máy có thể là đủ). Bởi vì trình biên dịch C thay đổi rất ít về chương trình, nói tương đối , khá dễ dàng để tái tạo lại một chương trình xấp xỉ tốt của mã nguồn C từ chương trình cũ. Trừ trường hợp lưu ý, các mã ngôn ngữ bậc cao mẫu trong cuốn sách này đều được viết bằng C.

#### C++

 - Ngôn ngữ lập trình C ++ là một phần mở rộng của C, và chia sẻ cú pháp cơ bản của C. C + + đưa C đến mức độ tiếp theo về tính linh hoạt và tinh tế bằng cách giới thiệu hỗ trợ cho lập trình hướng đối tượng. Điều quan trọng là C + + không áp đặt bất kỳ giới hạn mới về lập trình. Với một vài ngoại lệ nhỏ, bất kỳ chương trình nào có thể được biên dịch dưới một trình biên dịch C sẽ biên dịch dưới một trình biên dịch C ++.

 - Tính năng cốt lõi được giới thiệu trong C ++ là lớp(class). Một lớp cơ bản là một cấu trúc dữ liệu có thể có các thành viên mã, giống như các cấu trúc đối tượng được mô tả trong phần trên về cấu trúc mã. Các thành viên mã này thường quản lý dữ liệu được lưu trữ trong mỗi lớp. Điều này cho phép mức độ đóng gói cao hơn, nhờ đó cấu trúc dữ liệu được thống nhất với mã quản lý chúng. C + + cũng hỗ trợ thừa kế, đó là khả năng xác định một hệ thống phân cấp các lớp nâng cao chức năng của nhau. Thừa kế cho phép tạo ra các lớp cơ sở thống nhất một nhóm các lớp liên quan đến chức năng. Sau đó có thể xác định nhiều lớp dẫn xuất mở rộng chức năng của lớp cơ sở .

 - Vẻ đẹp thực sự của C ++ (và các ngôn ngữ hướng đối tượng khác) là đa hình (được thảo luận tóm tắt trong phần "Common Code Constructs"). Đa hình cho phép các lớp nguồn để ghi đè các thành viên được khai báo trong lớp cơ sở. Điều này có nghĩa là chương trình có thể sử dụng một đối tượng mà không biết loại dữ liệu chính xác-nó chỉ phải làm quen với lớp cơ sở. Bằng cách này, khi một hàm thành viên được gọi, các đối tượng nguồn cụ thể được gọi sẽ được thực hiện, ngay cả khi người gọi chỉ biết đến lớp cơ sở.

 - Mã đảo ngược được viết bằng C ++ tương tự như làm việc với mã C, ngoại trừ việc nhấn mạnh vào việc giải mã trình tự lớp của chương trình và xác định đúng các cuộc gọi phương thức lớp, các cuộc gọi của nhà xây dựng . Các kỹ thuật cụ thể để xác định cấu trúc C ++ trong mã ngôn ngữ lắp ráp được trình bày trong Phụ lục C.

`Trong trường hợp bạn không quen thuộc với cú pháp của C, C ++ sẽ rút ra tên của nó từ cú pháp C, trong đó xác định một tên biến theo sau là ++ cho biết biến đó sẽ được tăng lên bằng 1. C ++ tương đương với C = C +1.``

 - Java là một ngôn ngữ lập trình hướng đối tượng, ngôn ngữ bậc cao khác với các ngôn ngữ khác như C và C ++ vì nó không được biên dịch thành bất cứ ngôn ngữ lắp ráp nào của bộ vi xử lý một cách tự nhiên, mà lại là bytecode Java. Nói ngắn gọn, tập lệnh Java và bytecode giống như một ngôn ngữ lắp ráp của Java, với sự khác biệt mà ngôn ngữ này thường không được giải thích trực tiếp bởi phần cứng, nhưng lại được giải thích bằng phần mềm (Java Virtual Machine). Sức mạnh chính của Java là khả năng cho phép một chương trình chạy nhị phân trên bất kỳ nền tảng nào mà máy ảo Java (JVM) có sẵn. Bởi vì các chương trình Java chạy trên một máy ảo (VM), quá trình đảo ngược một chương trình Java hoàn toàn khác với việc đảo ngược các chương trình viết bằng các ngôn ngữ dựa trên trình biên dịch như C và C ++. Các tệp thi hành Java không sử dụng định dạng chuẩn thực thi của hệ điều hành (vì chúng không được thực thi trực tiếp trên CPU của hệ thống). Thay vào đó họ sử dụng các tệp .class, được nạp trực tiếp bởi máy ảo. 

 - Java bytecode chi tiết hơn nhiều so với mã máy xử lý gốc như IA-32, làm cho việc biên dịch lại trở nên khả thi hơn nhiều. Các lớp Java thường có thể được dịch ngược với độ chính xác rất cao, do đó quá trình đảo ngược các lớp Java thường đơn giản hơn nhiều so với mã nguồn gốc vì nó bắt đầu đọc một đại diện mã nguồn của chương trình. Chắc chắn, vẫn còn khó khăn để hiểu mã nguồn của chương trình không có giấy tờ, nhưng nó là dễ dàng hơn rất nhiều so với bắt đầu với một ngôn ngữ lắp ráp cấp thấp

### quan điểm cấp thấp

 - Sự phức tạp trong việc đảo chiều phát sinh khi chúng ta cố gắng tạo ra một liên kết trực quan giữa các khái niệm bậc cao được mô tả trước đó và quan điểm cấp thấp chúng ta có được khi chúng ta nhìn vào một chương trình nhị phân. Điều quan trọng là bạn phải phát triển một loại "hình ảnh tinh thần" về cấu trúc cấp cao như các thủ tục, các mô-đun, và các biến được thực hiện sau các tấm màn. Các phần sau đây mô tả cấu trúc chương trình cơ bản như cấu trúc dữ liệu và cấu trúc luồng điều khiển được trình bày ở cấp thấp hơn.

#### Quản lý dữ liệu cấp thấp

 - Một trong những khác biệt quan trọng nhất giữa ngôn ngữ lập trình cấp cao và bất kỳ dạng đại diện cấp thấp nào của chương trình là trong quản lý dữ liệu. Thực tế là các ngôn ngữ lập trình cấp cao giấu một số chi tiết về quản lý dữ liệu. Các ngôn ngữ khác nhau ẩn các mức chi tiết khác nhau, nhưng thậm chí ANSI C (được coi là một ngôn ngữ tương đối thấp trong đám mây ngôn ngữ bậc cao) giấu các chi tiết quản lý dữ liệu quan trọng từ các nhà phát triển.
 - Ví dụ, hãy xem xét đoạn mã ngôn ngữ C đơn giản sau đây:
```
int Multiply(int x, int y)
{
int z;
z = x * y;
return z;
}
```

 - cấu trúc này, đơn giản như nó có vẻ thế , nhưng  không bao giờ có thể được trực tiếp dịch sang một đại diện cấp thấp. Bất kể nền tảng nào, các CPU hiếm khi có các hướng dẫn để khai báo một biến hoặc để nhân hai biến để tạo ra một phần thứ ba. Các hạn chế về phần cứng và các cân nhắc về hiệu suất sẽ dẫn dắt và hạn chế mức độ phức tạp mà chỉ một lệnh có thể giải quyết. Mặc dù CPU Intel IA-32 hỗ trợ một loạt các hướng dẫn, một số trong đó đáng chú ý là mạnh mẽ, hầu hết các hướng dẫn này vẫn còn rất thô sơ so với khai báo trong ngôn ngữ cấp cao. Vì vậy, một đại diện cấp thấp của nhỏ khi dùng cấu trúc nhân thường sẽ phải chăm sóc các nhiệm vụ sau đây:

 1 Lưu trữ trạng thái máy trước khi thực hiện mã chức năng.
 2 phân bổ bộ nhớ cho z
 3 Load các thông số x và y từ bộ nhớ vào bộ nhớ xử lý nội bộ (thanh ghi)
 4 Nhân x by y và lưu kết quả vào một thanh ghi
 5 Tùy chọn sao chép kết quả nhân lại vào vùng nhớ được phân bổ trước cho z
 6 Phục hồi trạng thái máy được lưu trữ trước đó
 7 Quay trở lại người gọi và gửi trở lại z làm giá trị trả về.

 - Bạn có thể dễ dàng nhận thấy rằng sự phức tạp thêm là kết quả của những cân nhắc về quản lý dữ liệu cấp thấp. Các phần dưới đây giới thiệu các cấu trúc quản lý dữ liệu cấp thấp phổ biến nhất như thanh ghi, ngăn xếp và đống, và cách chúng liên quan đến các khái niệm cấp cao hơn như các biến và các tham số. 

 - Một câu hỏi xuất hiện trong tâm trí khi chúng tôi bắt đầu học về phần mềm mức thấp là tại sao những điều được trình bày theo một cách hoàn toàn khác biệt ở đó? Vấn đề cơ bản ở đây là tốc độ thực hiện trong bộ vi xử lý. Trong các máy tính hiện đại, CPU được gắn vào bộ nhớ hệ thống sử dụng kết nối tốc độ cao (xe buýt). Do tốc độ hoạt động cao của CPU, bộ nhớ RAM không có sẵn cho CPU. Điều này có nghĩa là CPU không thể gửi yêu cầu đọc cho bộ nhớ RAM và mong đợi trả lời ngay lập tức và cũng không thể thực hiện yêu cầu viết và mong đợi nó được hoàn thành ngay lập tức. Có nhiều lý do cho điều này, nhưng nó được gây ra chủ yếu bởi độ trễ kết hợp mà các thành phần liên quan giới thiệu. Đơn giản chỉ cần đặt, khi CPU yêu cầu một địa chỉ bộ nhớ nhất định được ghi vào hoặc đọc, thời gian cần cho lệnh đó đến chip nhớ và được xử lý, và để đáp ứng được gửi lại, lâu hơn một chu kỳ đồng hồ CPU . Điều này có nghĩa là bộ xử lý có thể lãng phí thời gian chỉ đơn giản là chờ đợi cho bộ nhớ RAM. Đây là lý do tại sao hướng dẫn hoạt động trực tiếp trên các toán hạng dựa trên bộ nhớ là nhanh hơn và tránh được bất cứ khi nào có thể. Khoảng thời gian tương đối dài mà mỗi lần truy cập bộ nhớ hoàn thành có nghĩa là có một lệnh đọc dữ liệu từ bộ nhớ, hoạt động trên dữ liệu đó và sau đó ghi kết quả vào bộ nhớ có thể không hợp lý so với khả năng thực hiện của bộ vi xử lý.

#### thanh ghi

 - Để tránh phải truy cập vào RAM cho mỗi chỉ lệnh, các bộ vi xử lý sử dụng bộ nhớ trong có thể được truy cập với ít hoặc không có hiệu suất. Có một số yếu tố khác nhau của bộ nhớ trong bên trong bộ vi xử lý trung bình, nhưng một trong những điểm quan tâm hiện tại là thanh ghi. Các thanh ghi là các khối nhỏ của bộ nhớ trong nằm trong bộ vi xử lý và có thể được truy cập rất dễ dàng, thường không có hiệu lỗi nào. Những nhược điểm với thanh ghi là thường nó có rất ít .Ví dụ, bộ vi xử lý IA-32 hiện tại chỉ có tám thanh ghi 32-bit thực sự được dùng chung. có khá nhiều loại khác nhưng hầu hết chúng đều có mục đích cụ thể và không phải lúc nào cũng được sử dụng. Mã ngôn ngữ lắp ráp xoay quanh thanh ghi vì chúng là cách đơn giản nhất để bộ xử lý có thể quản lý và truy cập dữ liệu ngay lập tức. Tất nhiên, thanh ghi hiếm khi được sử dụng để lưu trữ lâu dài, đó là nơi RAM bên ngoài đi vào hình ảnh. Điểm mấu chốt của tất cả những điều này là các CPU không tự động quản lý những vấn đề này mà được yêu cầu bằng mã ngôn ngữ lắp ráp. Thật không may, quản lý thanh ghi và tải và lưu trữ dữ liệu từ RAM để đăng ký và trở lại chắc chắn thêm một chút phức tạp đối với mã ngôn ngữ lắp ráp. 

 - Vì vậy, nếu chúng ta quay lại đoạn mã nhỏ của chúng tôi, hầu hết các phức tạp xoay quanh việc quản lý dữ liệu. x và y không thể được nhân trực tiếp từ bộ nhớ, mã đầu tiên phải đọc một trong số chúng vào một thanh ghi, và sau đó nhân thanh ghi bởi các giá trị khác mà vẫn còn trong bộ nhớ RAM. Cách tiếp cận khác là sao chép cả hai giá trị vào thanh ghi và sau đó nhân chúng từ thanh ghi đó, nhưng điều đó có thể là không cần thiết. Đây là những loại phức tạp được thêm vào bằng cách sử dụng thanh ghi, nhưng nó  cũng được sử dụng để lưu trữ nhiều giá trị dài hạn hơn. Bởi vìthanh ghi rất dễ truy cập, trình biên dịch sử dụng các thanh ghi để lưu trữ các giá trị được sử dụng thường xuyên trong phạm vi một hàm, và để lưu các biến địa phương được định nghĩa trong mã nguồn của chương trình.

 - Trong khi đảo chiều, điều quan trọng là phải thử và phát hiện bản chất của các giá trị nạp vào mỗi thanh ghi. Phát hiện trường hợp một thanh ghi được sử dụng đơn thuần để cho phép các hướng dẫn truy cập vào các giá trị cụ thể rất dễ dàng vì thanh ghi chỉ được sử dụng để chuyển giá trị từ bộ nhớ sang hướng dẫn hoặc theo cách khác. Trong các trường hợp khác, bạn sẽ thấy cùng một thanh ghi được sử dụng nhiều lần và cập nhật trong cả một chức năng đơn lẻ. Đây thường là dấu hiệu mạnh mẽ cho thấy thanh ghi đang được sử dụng để lưu trữ một biến cục bộ đã được định nghĩa trong mã nguồn. Tôi sẽ trở lại với quá trình xác định bản chất của các giá trị được lưu giữ bên trong thanh ghi trong Phần II, nơi tôi sẽ trình diễn nhiều phiên đảo ngược thế giới thực.

#### stack 

 - Hãy quay trở lại ví dụ Multiply trước đây của chúng ta và kiểm tra xem điều gì xảy ra trong Bước 2 khi chương trình phân bổ không gian lưu trữ cho biến "z". Các hành động cụ thể được thực hiện ở giai đoạn này sẽ phụ thuộc vào một số logic phức tạp xảy ra bên trong trình biên dịch. Ý tưởng chung là giá trị được đặt trong thanh ghi hoặc trên ngăn xếp. Đặt giá trị trong thanh ghi đơn giản có nghĩa là trong Bước 4 CPU sẽ được chỉ thị để đặt kết quả vào thanh ghi được phân bổ. thanh ghi sử dụng không được sự quản lý bởi bộ vi xử lý, và để bắt đầu sử dụng nó bạn chỉ cần tải một giá trị vào nó. Trong nhiều trường hợp, không có thanh ghi có sẵn hoặc có một lý do cụ thể tại sao một biến phải cư trú trong RAM và không phải trong thanh ghi.Trong những trường hợp như vậy, biến được đặt trên stack 

 - Một **stack** là một khu vực trong bộ nhớ chương trình được sử dụng để lưu trữ thông tin ngắn hạn bởi CPU và chương trình. Nó có thể được coi là một khu vực lưu trữ thứ cấp cho thông tin ngắn hạn. Các thanh ghi được sử dụng để lưu dữ liệu tức thời nhất, và ngăn xếp được sử dụng để lưu dữ liệu dài hơi. Về mặt vật lý, stack chỉ là một vùng trong RAM đã được phân bổ cho mục đích này. Stacks cư trú trong bộ nhớ RAM giống như bất kỳ dữ liệu khác - sự phân biệt là hoàn toàn hợp lý. Cần lưu ý rằng các hệ điều hành hiện đại quản lý nhiều ngăn xếp tại bất kỳ thời điểm nào - mỗi ngăn xếp đại diện cho một chương trình hoặc thread. đang hoạt động. Tôi sẽ thảo luận các chủ đề và cách phân chia và quản lý các ngăn xếp trong Chương 3.

 - Bên trong, ngăn xếp được quản lý rất đơn giản LIFO (vào cuối, ra đầu) cấu trúc dữ liệu, nơi mà các mục được "pushed" và "popped" vào chúng. Bộ nhớ cho ngăn xếp thường được phân bổ từ trên xuống, có nghĩa là các địa chỉ cao nhất được phân bổ và sử dụng trước và ngăn xếp phát triển "lùi lại" về phía các địa chỉ thấp hơn. Hình 2.1. thể hiện những gì ngăn xếp  sau khi push một số giá trị vào nó, và hình 2.2. cho thấy những gì nó  sau khi chúng được pop ra trở lại. 

 - Một ví dụ về việc sử dụng ngăn xếp có thể được nhìn thấy trong Bước 1 và 6. Trạng thái máy đang được lưu trữ thường là các giá trị của thanh ghi sẽ được sử dụng trong hàm. Trong những trường hợp này, thanh ghi các giá trị luôn luôn đẩy đến stack và sau đó được nạp lại từ stack vào thanh ghi tương ứng.

 ![](https://i.imgur.com/kwzLXdW.png)

 ![](https://i.imgur.com/9589MFA.png)

 - Nếu bạn cố gắng hiểu stack sang một quan điểm cấp cao, bạn sẽ thấy stack có thể được sử dụng cho một số thứ khác nhau .

 + **Giá trị thanh ghi được lưu tạm thời**: Ngăn xếp thường được sử dụng để lưu tạm thời giá trị của thanh ghi và sau đó khôi phục lại giá trị đã lưu vào thanh ghi đó.Điều này có thể được sử dụng trong nhiều tình huống - khi một thủ tục được gọi là cần sử dụng các thanh ghi nhất định. Trong những trường hợp như vậy, thủ tục có thể cần để bảo vệ các giá trị của thanh ghi để đảm bảo rằng nó không làm hỏng bất kỳ giá trị thanh ghi nào được sử dụng bởi người gọi của nó.

 +**biến địa phương**: Thông thường, sử dụng ngăn xếp để lưu các biến địa phương không khớp với thanh ghi của bộ vi xử lý hoặc cho các biến phải được lưu trữ trong bộ nhớ RAM (có nhiều lý do tại sao cần thiết, chẳng hạn như khi nào chúng ta muốn gọi một hàm và viết nó vào một biến cục bộ được định nghĩa trong hàm hiện tại. Cần lưu ý rằng khi xử lý dữ liệu biến cục bộ không phải là push và popped vào ngăn xếp, nhưng thay vì stack được truy cập bằng cách sử dụng offsets, như một cấu trúc dữ liệu. Một lần nữa, điều này sẽ được chứng minh khi bạn bước vào các phiên đảo ngược thật sự, trong phần thứ hai của cuốn sách này.

 - **Thông số chức năng và địa chỉ trả về**: Ngăn xếp được sử dụng để thực hiện cuộc gọi các cấu trúc. Trong một cuộc gọi cấu trúc, người gọi hầu như luôn luôn truyền các tham số cho cuộc gọi và có trách nhiệm lưu trữ con trỏ hướng dẫn vị trí hiện tại để chương trình có thể trở về lại vị trí ban đầu của nó khi cuộc gọi kết thúc. Ngăn xếp được sử dụng để lưu trữ cả hai tham số và con trỏ hướng dẫn cho mỗi cuộc gọi thủ tục.


#### Heaps

 - Heap là một vùng bộ nhớ được quản lý cho phép phân bổ động các khối bộ nhớ có kích thước biến đổi trong thời gian chạy. Một chương trình chỉ đơn giản yêu cầu một khối của một kích thước nhất định và nhận được một con trỏ đến khối mới được phân bổ (giả sử có đủ bộ nhớ có sẵn). Heap được quản lý hoặc bởi các thư viện phần mềm được vận chuyển cùng với các chương trình hoặc bởi hệ điều hành.

 - Heap thường được sử dụng cho các đối tượng có kích thước thay đổi được sử dụng bởi chương trình hoặc cho các đối tượng quá lớn để được đặt trên ngăn xếp. Đối với người đảo ngược, việc tìm các heaps trong bộ nhớ và xác định chính xác việc phân bổ heap và giải phóng nó có thể rất hữu ích, bởi vì nó góp phần vào sự hiểu biết tổng thể về bố cục dữ liệu của chương trình. Ví dụ, nếu bạn thấy một cuộc gọi đến những gì bạn biết là một thói quen phân bổ heap, bạn có thể lần theo luồng của giá trị trả lại của thủ tục trong suốt chương trình và xem những gì được thực hiện với khối được phân bổ, v.v ... Ngoài ra, có thông tin kích thước chính xác về các đối tượng phân bổ heap (kích thước khối luôn được truyền như là một tham số cho thói quen phân bổ heap) là một gợi ý nhỏ khác hướng tới sự hiểu biết của chương trình.

#### Các mục dữ liệu thực thi.

 - Một khu vực khác trong bộ nhớ chương trình thường được sử dụng để lưu trữ dữ liệu ứng dụng là phần dữ liệu thực thi. Trong các ngôn ngữ bậc cao, khu vực này thường có chứa các biến toàn cầu hoặc dữ liệu đã được định sẵn. Dữ liệu đã được định sẵn là bất kỳ loại thông tin cố định,  mã cứng nào bao gồm trong chương trình. Một số dữ liệu preinitialized được nhúng ngay vào mã (chẳng hạn như các giá trị số nguyên không đổi, v.v ...), nhưng khi có quá nhiều dữ liệu, trình biên dịch lưu trữ nó bên trong một khu vực đặc biệt trong chương trình thực thi và tạo ra mã tham chiếu nó theo địa chỉ. Một ví dụ tuyệt vời về dữ liệu được preinitialized là bất kỳ chuỗi mã cứng nào bên trong một chương trình. Sau đây là một ví dụ về kiểu chuỗi này.

```
char szWelcome = “This string will be stored in the executable’s
preinitialized data section”;

```

 - Định nghĩa này, được viết bằng C, sẽ khiến trình biên dịch lưu trữ chuỗi trong phần dữ liệu preinitialized của tập tin thực thi, bất kể nơi nào trong mã szWelcome được khai báo. Ngay cả khi szWelcome là một biến cục bộ được khai báo bên trong một hàm, chuỗi sẽ vẫn được lưu trữ trong phần dữ liệu preinitialized. Để truy cập vào chuỗi này, trình biên dịch sẽ phát ra một địa chỉ cứng mã hóa trỏ đến chuỗi. Điều này có thể dễ dàng xác định trong khi đảo ngược một chương trình, bởi vì các địa chỉ bộ nhớ cứng mã hoá hiếm khi được sử dụng cho bất cứ điều gì khác hơn là trỏ đến phần dữ liệu thực thi. 

 - Trường hợp phổ biến khác trong đó dữ liệu được lưu trữ bên trong phần dữ liệu thực thi là khi chương trình định nghĩa một biến toàn cầu. Các biến toàn cầu cung cấp lưu trữ lâu dài (giá trị của chúng được giữ lại trong suốt chương trình) có thể truy cập từ bất kỳ nơi nào trong chương trình, do đó nên được dùng thuật ngữ là "toàn cầu". Trong hầu hết các ngôn ngữ, một biến toàn cục được định nghĩa bằng cách khai báo nó bên ngoài phạm vi của bất kỳ hàm nào. Giống như dữ liệu được preinitialized, trình biên dịch phải sử dụng các địa chỉ bộ nhớ cứng để truy cập vào các biến toàn cầu, đó là lý do tại sao chúng dễ dàng nhận ra khi đảo ngược một chương trình.

#### điều khiển luồng.

 - Kiểm soát luồng là một trong những khu vực mà mã nguồn đại diện thực sự làm cho mã trông thân thiện.Tất nhiên, hầu hết các bộ vi xử lý và ngôn ngữ cấp thấp chỉ không biết ý nghĩa của từ "IF" hoặc WHILE. Nhìn vào việc thực hiện cấp thấp của một tuyên bố dòng điều khiển đơn giản thường gây nhầm lẫn, bởi vì các cấu trúc dòng điều khiển được sử dụng trong các lĩnh vực cấp thấp là khá nguyên thủy. Thách thức là chuyển các cấu trúc nguyên thủy này trở lại các khái niệm cấp cao thân thiện với người dùng. 

 - Một trong những vấn đề là hầu hết các câu lệnh có điều kiện cấp cao chỉ quá dài đối với các ngôn ngữ cấp thấp như ngôn ngữ lắp ráp, vì vậy chúng được chia thành các dãy các phép toán. Chìa khóa để hiểu được các trình tự, sự tương quan giữa chúng, và các câu lệnh cấp cao từ đó chúng bắt nguồn, là hiểu các cấu trúc của dòng điều khiển mức thấp và cách chúng có thể được sử dụng để biểu diễn các câu lệnh điều khiển mức cao. Các chi tiết của các cấu trúc cấp thấp này là nền tảng và ngôn ngữ cụ thể; chúng ta sẽ thảo luận các câu lệnh kiểm soát dòng chảy trong ngôn ngữ lắp ráp IA-32 trong phần sau về ngôn ngữ lắp ráp.

#### assembly Language 101

 - để hiểu về các phần mềm bậc thấp , chúng ta phải hiểu biết về assembly Language . cho hầu hết các mục đích assembly là ngôn ngữ cho reverse, và làm chủ nó là một bước thiết yếu để trở thành một người đảo ngược thực sự, bởi vì với hầu hết các chương trình ngôn ngữ lắp ráp có đặc điểm là chỉ có liên kết có thể dùng với mã nguồn gốc. Thật không may, có khá nhiều khoảng cách giữa mã nguồn của hầu hết các chương trình và mã ngôn ngữ lắp ráp tạo ra do trình biên dịch, chúng ta phải làm việc trong khi kỹ thuật đảo ngược. Nhưng đừng sợ, cuốn sách này có chứa nhiều kỹ thuật để lấy ra mọi thông tin có thể có từ các chương trình ngôn ngữ lắp ráp!

 - Các phần sau đây cung cấp một sự giới thiệu nhanh về thế giới của ngôn ngữ lắp ráp, trong khi tập trung vào IA-32 (kiến trúc 32-bit của Intel), đây là cơ sở cho tất cả các CPU x86 của Intel từ lịch sử 80386 đến hiện đại ngày nay. Tôi đã chọn tập trung vào ngôn ngữ lắp ráp Intel IA-32 bởi vì nó được sử dụng trong mọi máy tính trên thế giới và là kiến trúc bộ xử lý phổ biến nhất hiện nay. Các CPU tương thích với Intel, chẳng hạn như các sản phẩm của Advanced Micro Devices (AMD), Transmeta, v.v ... hầu như giống hệt nhau cho mục đích đảo chiều vì chúng tương thích với bộ xử lý của Intel.

#### register

 - Trước khi bắt đầu nhìn vào những lệnh ngôn ngữ lắp ráp cơ bản nhất, bạn phải làm quen với thanh ghi IA-32, bởi vì bạn sẽ thấy chúng được tham chiếu trong hầu hết các hướng dẫn lắp ráp ngôn ngữ mà bạn sẽ gặp phải. Đối với hầu hết các mục đích, IA-32 có tám thanh ghi chung: EAX, EBX, ECX, EDX, ESI, EDI, EBP và ESP. Ngoài những kiến trúc này, kiến trúc cũng hỗ trợ một chồng các thanh ghi nối - điểm và nhiều thanh ghi khác phục vụ các yêu cầu ở cấp độ hệ thống cụ thể, nhưng hiếm khi được sử dụng bởi các ứng dụng và sẽ không được thảo luận ở đây. Mã chương trình thông thường chỉ sử dụng tám thanh ghi chung.

 - Bảng 2.1 cung cấp mô tả ngắn gọn về các thanh ghi và các cách sử dụng phổ biến nhất của chúng.

 - Lưu ý rằng tất cả các tên này bắt đầu bằng chữ E, có nghĩa là mở rộng. Các tên thanh ghi này đã được chuyển từ kiến trúc Intel 16-bit cũ hơn, nơi chúng có cùng tên chính xác, trừ Es (để EAX được gọi là AX, vv). Điều này rất quan trọng bởi vì đôi khi bạn sẽ chạy vào mã 32-bit mà các thanh ghi tham chiếu theo cách đó: `MOV AX, 0x1000`, v.v. Hình 2.3. cho thấy tất cả các thanh ghi đa năng và tên khác nhau của họ.

 ** bảng 2.1** :các thanh ghi mô tả về chúng

| thanh ghi| mục đích của thanh ghi|
|----------|-----------------------|
|EAX, EBX, EDX | Đây là tất cả các thanh ghi chung có thể được sử dụng cho bất kỳ số nguyên, Boolean, logic, hoặc bộ nhớ chương trình.|
| ECX | thanh ghi dùng Chung, đôi khi được sử dụng với mục đích riêng như một bộ đếm bằng các hướng dẫn lặp đi lặp lại đòi hỏi đếm.|
| ESI/EDI | được dùng chung, thường được sử dụng như là các con trỏ nguồn / đích trong các hướng dẫn sao chép bộ nhớ (SI là viết tắt của Source Index, và DI là viết tắt của Destination Index).|
| EBP | Có thể được sử dụng như là một thanh ghi chung, nhưng chủ yếu được sử dụng như con trỏ stack. Sử dụng một con trỏ cơ sở kết hợp với con trỏ stack tạo ra một ngăn xếp khung. Một ngăn xếp khung có thể được định nghĩa là vùng ngăn xếp của chức năng hiện tại, nằm giữa con trỏ ngăn xếp (ESP) và con trỏ cơ sở (EBP). con trỏ cơ sở thường chỉ đến vị trí ngăn xếp ngay sau địa chỉ trả về cho hàm hiện tại. Khung xếp chồng được sử dụng để đạt được quyền truy cập nhanh và thuận tiện cho cả các biến cục bộ và các tham số truyền cho hàm hiện tại.|
| ESP | Đây là con trỏ ngăn xếp CPU. Con trỏ stack lưu trữ vị trí hiện tại trong ngăn xếp, do đó bất cứ thứ gì được đẩy đến stack sẽ bị đẩy xuống dưới địa chỉ này, và thanh ghi này được cập nhật cho phù hợp.| 

 **hình 2.3** thanh ghi đa dụng trong IA-32.
![](https://i.imgur.com/WSqqDnD.png)

#### thanh ghi cờ ( flag)

 - Bộ vi xử lý IA-32 có một thanh ghi đặc biệt gọi là EFLAGS chứa tất cả các loại trạng thái và cờ hệ thống. Các cờ hệ thống được sử dụng để quản lý các chế độ xử lý khác nhau và các trạng thái, và không liên quan đến cuộc thảo luận này. Các cờ trạng thái, mặt khác, được sử dụng bởi bộ vi xử lý để ghi trạng thái logic hiện tại của nó và được cập nhật bằng nhiều hướng dẫn lôgic và số học để ghi lại kết quả của hành động của chúng. Ngoài ra, có các hướng dẫn hoạt động dựa trên các giá trị của các cờ trạng thái này để nó có thể tạo ra các trình tự thực hiện các thao tác khác nhau dựa trên các giá trị đầu vào khác nhau, v.v ...

 - Trong mã IA-32, cờ là một công cụ cơ bản để tạo điều kiện cho mã. Có các hướng dẫn số học kiểm tra các toán hạng đối với các điều kiện nhất định và đặt cờ cho bộ xử lý dựa trên các giá trị của chúng. Sau đó, có những hướng dẫn đọc các cờ này và thực hiện các thao tác khác nhau tùy thuộc vào các giá trị nạp vào các cờ. Một nhóm lệnh phổ biến hoạt động dựa trên các giá trị cờ là các hướng dẫn Jcc (Conditional Jump), kiểm tra các giá trị cờ nhất định (phụ thuộc vào lệnh cụ thể được gọi) và nhảy tới một địa chỉ mã xác định nếu các cờ được đặt đúng theo điều kiện được mã chỉ định

 - Chúng ta hãy nhìn vào một ví dụ để xem làm thế nào có thể tạo ra một tuyên bố có điều kiện như những gì chúng ta đang sử dụng để nhìn thấy trong các ngôn ngữ cấp cao sử dụng cờ. Giả sử bạn có một biến được gọi là bSuccess trong ngôn ngữ cấp cao và bạn có mã để kiểm tra xem nó có sai hay không. Mã có thể trông như thế này:

```
if (bSuccess == FALSE) return 0;
```
 - Dòng này sẽ như thế nào trong ngôn ngữ lắp ráp? Nói chung không phải là có thể kiểm tra giá trị của một biến và hành động trên giá trị đó trong một lệnh đơn giản nhất là khi nó quá thô sơ cho điều đó. Thay vào đó, chúng ta phải kiểm tra giá trị của bSuccess (có thể sẽ được nạp vào thanh ghi đầu tiên), thiết lập một số cờ mà sẽ ghi lại cho dù đó là bằng không hoặc khác không, và gọi lệnh chi nhánh có điều kiện sẽ kiểm tra cờ cần thiết và nhánh nếu chúng chỉ ra rằng toán hạng xử lý trong lệnh gần đây nhất là zero (điều này được chỉ ra bởi Zero Flag, ZF).Nếu không, bộ xử lý sẽ chỉ tiến hành thực hiện lệnh sau lệnh chi nhánh. Ngoài ra, trình biên dịch có thể đảo ngược các điều kiện và chi nhánh nếu bSuccess là khác không. Có nhiều yếu tố xác định xem các trình biên dịch có điều kiện ngược lại hay không. Chủ đề này được thảo luận chi tiết trong Phụ lục A.

#### định dạng lệnh 

 - Trước khi chúng tôi bắt đầu thảo luận từng hướng dẫn ngôn ngữ lắp ráp, tôi muốn giới thiệu cách bố trí cơ bản của hướng dẫn IA-32. Các lệnh thường bao gồm một opcode (mã hoạt động), và một hoặc hai toán hạng.Mã opcode là một tên lệnh như MOV, và các toán hạng là các tham số "" mà chỉ lệnh nhận được (một số lệnh không có toán hạng).Đương nhiên, mỗi hướng dẫn đòi hỏi các toán hạng khác nhau vì mỗi toán tử đều thực hiện một nhiệm vụ khác nhau. Các toán tử đại diện cho dữ liệu được xử lý bởi chỉ lệnh cụ thể (giống như các tham số truyền đến một hàm), và trong ngôn ngữ lắp ráp, dữ liệu có ba dạng cơ bản:
 <ul>
 <li> **tên thanh ghi** : Tên của một thanh ghi đa dụng phải được đọc hoặc ghi vào. Trong IA-32, điều này sẽ giống như EAX, EBX, v.v.</li>
 <li> **trực tiếp** : Giá trị không đổi được nhúng ngay trong mã. Điều này thường chỉ ra rằng có một số loại hằng số mã hoá cố định trong chương trình gốc.</li>
 <li> **địa chỉ bộ nhớ** : Khi một toán hạng nằm trong RAM, địa chỉ bộ nhớ của nó được đính kèm trong ngoặc đơn để chỉ ra rằng nó là một địa chỉ bộ nhớ. Địa chỉ có thể là một mã vạch cứngtrực tiếp chỉ cho bộ xử lý biết địa chỉ chính xác để đọc hoặc ghi vào hoặc nó có thể là thanh ghi có giá trị sẽ được sử dụng làm địa chỉ bộ nhớ. Cũng có thể kết hợp một thanh ghi với một số học và một hằng số, trong đó thanh ghi đại diện cho địa chỉ cơ sở của một số đối tượng, và hằng đại diện cho một offset vào đối tượng đó hoặc một chỉ mục vào một mảng</li>
 </ul>

 - Định dạng lệnh tổng thể giống như thế này: 

```
Instruction Name (opcode) Destination Operand, Source Operand
```

 - Một số chỉ dẫn chỉ có một toán hạng, mà mục đích của nó phụ thuộc vào chỉ dẫn cụ thể. Các hướng dẫn khác không có toán hạng và hoạt động trên dữ liệu được xác định trước. Bảng 2.2 cung cấp một vài ví dụ điển hình của các toán hạng và giải thích ý nghĩa của chúng.

#### lệnh cơ bản

 - Bây giờ bạn đã quen thuộc với thanh ghi IA-32, chúng ta có thể chuyển sang một số hướng dẫn cơ bản. Đây là những hướng dẫn phổ biến xuất hiện ở mọi nơi trong một chương trình. Xin lưu ý rằng ở đây  không nơi nào có một danh sách đầy đủ các hướng dẫn IA-32. Nó chỉ là một cái nhìn tổng quan về những cái phổ biến nhất. Để biết thông tin chi tiết về từng hướng dẫn tham khảo Hướng dẫn của Nhà phát triển phần mềm Kiến trúc Intel IA-32, Khối lượng 2A và Khối lượng 2B [Intel2, Intel3]. Đây là những hướng dẫn sử dụng IA-32 (sẵn có miễn phí) của Intel.

 **Bảng 2.2** Các ví dụ về các toán tử chỉ dẫn điển hình và ý nghĩa của nó.

|toán tử | mô tả |
|--------|-------|
|EAX |Đơn giản chỉ cần tham khảo EAX, để đọc hoặc viết |
| 0x30004040 | Một số trực tiếp được nhúng trong mã (như một hằng số)|
| [0x4000349e] | Một địa chỉ bộ nhớ mã cứng trực tiếp - đây có thể là một truy cập biến toàn cục|

-----------------------------------------------------------------

 ** ghi chú về assembly Language 
  - Mặc dù định dạng hướng dẫn lắp ráp ngôn ngữ được mô tả ở đây tuân theo ký hiệu được sử dụng trong tài liệu chính thức IA-32 do Intel cung cấp nhưng nó không phải là ký hiệu duy nhất được sử dụng để trình bày mã ngôn ngữ lắp ráp IA-32. Ký hiệu Unix của AT & T là một ký pháp khác cho các hướng dẫn lắp ráp bằng ngôn ngữ khác hoàn toàn với ký hiệu Intel. Trong ký hiệu AT & T, toán hạng nguồn thường đi trước toán hạng đích (ngược với cách nó được thực hiện trong ký hiệu Intel). Ngoài ra, tên đăng ký được đặt trước bằng một% (để EAX được tham chiếu là% eax). Các ký tự AT & T được sử dụng chủ yếu trong các công cụ phát triển Unix như các công cụ GNU, trong khi ký hiệu Intel chủ yếu được sử dụng trong các công cụ của Windows, đó là lý do tại sao cuốn sách này sử dụng ký hiệu Intel cho các danh sách ngôn ngữ lắp ráp.**

------------------------------------------------------

#### Di chuyển dữ liệu.

 - Chỉ dẫn MOV có lẽ là hướng dẫn phổ biến nhất của IA-32. MOV lấy hai toán hạng: toán hạng đích và toán hạng nguồn, và chỉ cần di chuyển dữ liệu từ nguồn đến đích. Toán hạng đích có thể là một địa chỉ bộ nhớ (thông qua một thanh ghi trực tiếp hoặc sử dụng một thanh ghi)  . Toán hạng nguồn có thể là một địa chỉ trực tiếp, thanh ghi hoặc bộ nhớ, nhưng lưu ý rằng chỉ có một trong số các toán hạng có thể là một địa chỉ bộ nhớ, và không bao giờ cả hai. Đây là một quy tắc chung trong hướng dẫn IA-32: với một vài trường hợp ngoại lệ, hầu hết các chỉ lệnh chỉ có thể có một toán hạng bộ nhớ. Đây là "nguyên mẫu" của lệnh MOV:

```
MOV DestinationOperand, SourceOperand 
ví dụ: MOV EAX,EBX 
```

 - Vui lòng xem phần "Ví dụ" ở phần sau của chương này để hiểu rõ hơn cách sử dụng MOV và các hướng dẫn khác trong mã thực.

#### SỐ HỌC 

 - Đối với các phép tính số học cơ bản, tập lệnh hướng dẫn IA-32 bao gồm 6 chỉ dẫn số học số nguyên cơ bản: ADD, SUB, MUL, DIV, IMUL và IDIV. Bảng dưới đây cung cấp định dạng phổ biến cho mỗi hướng dẫn cùng với mô tả ngắn gọn. Lưu ý rằng nhiều hướng dẫn này hỗ trợ các cấu hình khác, với các bộ toán hạng khác nhau. Bảng 2.3 cho thấy cấu hình phổ biến nhất cho mỗi hướng dẫn.

**hình 2.3 **:Cấu hình tiêu biểu của Hướng dẫn số học IA-32 cơ bản

| câu lệnh | mô tả câu lệnh |
|----------|-------------|
| `ADD toán hạng 1, toán hạng 2` | cộng hai số nguyên có dấu hoặc không dấu, kết quả thường được lưu trong toán hạng 1 |
| `SUB toán hạng 1, toán hạng 2` |  trừ giá trị của toán hạng 2 từ giá trị của  toán hạng 1. Kết quả thường được lưu trữ trong toán hang 1. lệnh này hoạt động cho cả toán hạng có dấu và không dấu|
| `MUL Operand` | Nhân toán toán hạng không dấu bởi EAX và lưu trữ kết quả trong một giá trị 64-bit trong EDX: EAX. EDX: EAX có nghĩa là 32 bit thấp (ít quan trọng nhất) được lưu trữ trong EAX và 32 bit cao (quan trọng nhất) được lưu trữ trong EDX. Đây là một sự sắp xếp chung trong câu lệnh IA-32.|
| `DIV Operand` | Chia giá trị không dấu 64 bit và kết quả được lưu trữ trong EDX: EAX bởi số không dấu operand . Lưu trữ giá trị trong EAX và phần còn lại của EDX|
| `IMUL Operand` |Nhân toán toán hạng có dấu với EAX và lưu trữ kết quả trong một giá trị 64-bit trong EDX: EAX.|
| `IDIV Operand` | Chia toán hạng 64-bit có dấu cho giá trị được lưu trữ trong EDX: EAX . Lưu trữ số chia được trong EAX và phần còn lại của EDX. |

#### So sánh toán tử

 - Các toán tử được so sánh bằng cách sử dụng lệnh CMP, có hai toán hạng: 

```
CMP
Operand1, Operand2
```

 - CMP ghi lại kết quả của việc so sánh trong cờ của bộ xử lý. Về bản chất, CMP đơn giản chỉ lấy Operand1  trừ Operand2 và không ghi lại kết quả, trong khi thiết lập tất cả các cờ liên quan để phản ánh chính xác kết quả của phép trừ. Ví dụ, nếu kết quả của phép trừ là zero, Zero Flag (ZF) được thiết lập, cho biết rằng hai toán hạng đều bằng nhau. Cùng một cờ có thể được sử dụng để xác định nếu các toán hạng không bằng nhau, bằng cách kiểm tra ZF có được thiết lập hay không ( ZF=1 thì 2 toán hạng bằng nhau , =0 thì hai toán hạng khác nhau) Có các cờ khác được thiết lập bởi CMP có thể được sử dụng để xác định toán hạng nào là lớn hơn, phụ thuộc vào việc các toán hạng có dấu hoặc không dấu. Để biết thêm thông tin về những cờ cụ thể này, xem Phụ lục A.

#### điều kiện rẽ nhánh

 - điều kiện rẻ nhánh được thực hiện bằng cách sử dụng nhóm hướng dẫn Jcc. Đây là những hướng dẫn có kèm điều kiện rẻ nhánh đến một địa chỉ được chỉ định, dựa trên các điều kiện nhất định. Jcc chỉ là một tên chung, và có khá nhiều biến thể khác nhau. Mỗi biến thể kiểm tra các giá trị cờ khác nhau để quyết định có thực hiện rẻ nhánh hay không. Các biến thể cụ thể được thảo luận trong Phụ lục A.

 - Định dạng cơ bản của một lệnh điều kiện rẻ nhánh như sau: 

```
Jcc TargetCodeAddress
```

 - Nếu điều kiện quy định được thỏa mãn, JCC sẽ chỉ cập nhật con trỏ chỉ dẫn để trỏ đến TargetCodeAddress (mà không lưu giá trị hiện tại của nó). Nếu điều kiện không thỏa mãn, Jcc sẽ không làm gì cả và việc thực hiện sẽ tiến hành theo câu lệnh sau.

#### cuộc gọi hàm 

 - Các cuộc gọi hàm được thực hiện bằng cách sử dụng hai hướng dẫn cơ bản trong ngôn ngữ lắp ráp. Lệnh `CALL` gọi một hàm, và lệnh `RET` trả về cho người gọi. lệnh CALL đẩy con trỏ lệnh hiện hành vào ngăn xếp (để sau đó có thể trở lại với người gọi) và nhảy tới địa chỉ được chỉ định. Địa chỉ của hàm có thể được chỉ định giống như bất kỳ toán tử nào khác, như là một địa chỉ trực tiếp, thanh ghi hoặc bộ nhớ. Sau đây là cách bố trí chung của lệnh CALL. 

```
CALL FunctionAddress
```

 - Khi một hàm hoàn thành và cần quay trở lại nơi gọi, nó thường gọi lệnh RET. RET pops con trỏ hướng dẫn từng được đẩy vào ngăn xếp bởi CALL và tiếp tục thực hiện từ địa chỉ đó. Ngoài ra, RET có thể được chỉ thị để tăng ESP bằng số byte được chỉ định sau khi popping con trỏ hướng dẫn. Điều này là cần thiết để khôi phục lại ESP trở lại vị trí ban đầu của nó như nó đã được trước khi chức năng hiện tại đã được gọi và trước khi bất kỳ tham số đã được đẩy lên ngăn xếp. Trong một số quy ước người gọi có trách nhiệm điều chỉnh ESP, có nghĩa là trong trường hợp như vậy RET sẽ được sử dụng mà không có toán hạng nào, và người gọi sẽ phải tăng ESP theo cách thủ công bởi số byte được đẩy như các tham số. Thông tin chi tiết về công ước kêu gọi có trong Phụ lục C. 

 **ví dụ**

 - Hãy xem nhanh vài đoạn ngắn về ngôn ngữ lắp ráp, chỉ để đảm bảo rằng bạn hiểu các khái niệm cơ bản. Đây là ví dụ đầu tiên:

```
cmp ebx,0xf020
jnz 10026509
```

 - Chỉ thị đầu tiên là CMP, so sánh hai toán hạng được chỉ định. Trong trường hợp này, CMP đang so sánh giá trị hiện tại của thanh ghi EBX với hằng số: 0xf020 (tiền tố "0x" cho biết một số thập lục phân), hoặc 61.472 theo thập phân. Như bạn đã biết, CMP sẽ thiết lập cờ nhất định để phản ánh kết quả so sánh. lệnh tiếp theo là JNZ. JNZ là một phiên bản của nhóm các hướng dẫn được Jcc mô tả dưới đây. Phiên bản cụ thể được sử dụng ở đây sẽ rẻ nhánh nếu cờ zero (ZF) không được thiết lập, đó là lý do tại sao lệnh được gọi là JNZ (jump if not zero). Về cơ bản điều này có nghĩa là chỉ dẫn sẽ nhảy đến địa chỉ mã xác định nếu các toán hạng so sánh trước đó bởi CMP không bằng nhau. Đó là lý do tại sao JNZ còn được gọi là JNE (nhảy nếu không bằng nhau). JNE và JNZ là hai phép ghi nhớ khác nhau cho cùng một chỉ dẫn - chúng thực sự chia sẻ cùng một opcode trong ngôn ngữ máy.

 - Hãy tiếp tục một ví dụ khác cho thấy việc di chuyển dữ liệu và phép toán số học:

```
mov edi,[ecx+0x5b0]
mov ebx,[ecx+0x5b4]
imul edi,ebx
```

 - Trình tự này bắt đầu với một lệnh MOV đọc một địa chỉ từ bộ nhớ vào thanh ghi EDI . Dấu ngoặc chỉ ra rằng đây là một truy cập bộ nhớ, và địa chỉ cụ thể cần đọc được xác định bên trong dấu ngoặc. Trong trường hợp này, MOV sẽ lấy giá trị của ECX, cộng thêm 0x5b0 (1456 trong thập phân), và sử dụng kết quả như một địa chỉ bộ nhớ. lệnh sẽ đọc 4 byte từ địa chỉ đó và ghi chúng vào EDI. Bạn biết rằng 4 byte sẽ được đọc vìthanh ghi được chỉ định là toán hạng đích. Nếu chỉ dẫn để tham khảo đến DI thay vì EDI, bạn sẽ biết rằng chỉ có 2 byte sẽ được đọc. EDI là một thanh ghi 32-bit đầy đủ (xem Hình 2.3 để minh hoạ các thanh ghi IA-32 và kích thước của chúng).

 - Lệnh sau đọc một địa chỉ bộ nhớ khác, lần này từ ECX cộng với 0x5b4 vào thanh ghi EBX. Bạn có thể dễ dàng suy luận rằng ECX chỉ ra một số loại cấu trúc dữ liệu. 0x5b0 và 0x5b4 là phần bù cho một số thành viên trong cấu trúc dữ liệu đó. Nếu đây là một chương trình thực sự, bạn có thể muốn thử và tìm hiểu thêm thông tin về cấu trúc dữ liệu này được chỉ ra bởi ECX. Bạn có thể thực hiện điều đó bằng cách truy xuất lại mã để xem ECX được nạp với giá trị hiện tại của nó. Điều đó sẽ cho bạn biết địa chỉ của cấu trúc này có được, và có thể làm sáng tỏ bản chất của cấu trúc dữ liệu này. Tôi sẽ trình diễn tất cả các loại kỹ thuật để điều tra cấu trúc dữ liệu trong các ví dụ đảo chiều trong suốt cuốn sách này.

 - Các lệnh cuối cùng trong chuỗi này là lệnh IMUL ( nhân có dấu) . IMUL có nhiều dạng khác nhau, nhưng khi được chỉ ra với hai toán hạng như ở đây, có nghĩa là toán hạng đầu tiên được nhân với lần thứ hai và kết quả được ghi vào toán hạng đầu tiên. Điều này có nghĩa là giá trị của EDI sẽ được nhân với giá trị của EBX và kết quả sẽ được ghi lại vào EDI. 

 - Nếu bạn nhìn vào ba hướng dẫn này như một tổng thể, bạn có thể có được một ý tưởng tốt về mục đích của họ. Về cơ bản họ lấy hai thành viên khác nhau của cùng một cấu trúc dữ liệu (có địa chỉ được lấy từ ECX), và nhân nó. Ngoài ra, vì IMUL được sử dụng, bạn biết rằng các thành viên này là số nguyên có dấu, rõ ràng là 32-bit dài. Không quá tệ cho ba dòng mã assembly!

 - Ví dụ cuối cùng, chúng ta hãy nhìn vào trình tự gọi hàm trung bình trong ngôn ngữ lắp ráp IA-32:

```
push eax
push edi
push ebx
push esi
push dword ptr [esp+0x24]
call 0x10026eeb
```
 - Chuỗi này đẩy 5 giá trị vào ngăn xếp bằng cách sử dụng lệnh PUSH. Bốn giá trị đầu tiên được đẩy là tất cả lấy từ thanh ghi. Giá trị thứ năm và cuối cùng được lấy từ địa chỉ bộ nhớ tại ESP cộng với 0x24. Trong hầu hết các trường hợp, đây sẽ là một địa chỉ stack (ESP là con trỏ ngăn xếp), có thể cho biết rằng địa chỉ này là hoặc là một tham số đã được truyền đến hàm hiện tại hoặc một biến cục bộ. Để xác định chính xác địa chỉ này đại diện điều gì, bạn sẽ cần phải nhìn vào toàn bộ chức năng và kiểm tra nó sử dụng stack như thế nào. Tôi sẽ trình diễn các kỹ thuật để thực hiện điều này trong Chương 5.

#### Một cơ sở về trình biên dịch và biên dịch

 - Nó sẽ là an toàn để nói rằng 99 phần trăm của tất cả các phần mềm hiện đại được thực hiện bằng cách sử dụng ngôn ngữ cấp cao và đi qua một số loại trình biên dịch trước khi được chuyển đến khách hàng. Vì vậy, nó cũng là an toàn để nói rằng hầu hết, nếu không phải là tất cả, tình huống đảo ngược bạn sẽ gặp phải bao gồm các thách thức của deciphering đầu ra back-end của một trình biên dịch hoặc khác.

 - Do đó, có thể hữu ích để phát triển sự hiểu biết chung về trình biên dịch và cách chúng hoạt động. Bạn có thể xem xét một loại chiến lược "biết kẻ thù của bạn", điều này sẽ giúp bạn hiểu và đối phó với những khó khăn trong việc giải mã mã trình biên dịch. Mã trình biên dịch tạo ra có thể khó đọc. Đôi khi nó rất khác so với cấu trúc mã ban đầu của chương trình mà nó trở nên khó khăn để xác định ý định ban đầu của nhà phát triển phần mềm. Một vấn đề tương tự xảy ra với các trình tự số học: chúng thường được sắp xếp lại để làm cho chúng trở nên hiệu quả hơn, và kết thúc bằng một dãy các phép toán số học kỳ quặc có thể rất khó hiểu. Điểm mấu chốt là việc phát triển sự hiểu biết về các quy trình được thực hiện bởi trình biên dịch và cách mà họ "nhận thức" mã sẽ giúp giải mã đầu ra của chúng.

 - Các phần sau cung cấp một số thông tin cơ bản về trình biên dịch và cách chúng hoạt động, và mô tả các giai đoạn khác nhau diễn ra bên trong trình biên dịch trung bình. Mặc dù các phần sau đây có thể được coi là không bắt buộc nhưng tôi vẫn khuyên bạn nên đi qua các điểm này nếu bạn không quen với các khái niệm cơ bản biên dịch. Tôi tin chắc rằng những người đảo ngược phải biết hệ thống của họ, và không ai có thể thực sự đòi hỏi phải hiểu được hệ thống mà không hiểu làm thế nào để tạo ra và xây dựng phần mềm.

 - Cần nhấn mạnh rằng trình biên dịch là các chương trình rất phức tạp kết hợp nhiều lĩnh vực trong nghiên cứu khoa học máy tính và có thể có hàng triệu dòng mã. Các phần dưới đây không phải là toàn diện - chúng chỉ là vết xước bề mặt. Nếu bạn muốn nâng cao kiến thức về các trình biên dịch và tối ưu hóa trình biên dịch, bạn nên kiểm tra [Cooper] Keith D. Copper và Linda Torczon. ** Engineering a Compiler **. Nhà xuất bản Morgan Kaufmann, 2004, để có hướng dẫn dễ hiểu về các kỹ thuật biên soạn, hoặc [Muchnick] Steven S. Muchnick. **Advanced Compiler Design and Implementation**. Nhà xuất bản Morgan Kaufmann, 1997, để thảo luận chi tiết về các tài liệu biên soạn tiên tiến như tối ưu hoá, v.v ...

#### Định nghĩa một trình biên dịch

 - Ở mức cơ bản nhất của nó, trình biên dịch là một chương trình mà phải mất một đại diện của một chương trình như là đầu vào của nó và tạo ra một đại diện khác nhau của cùng một chương trình. trong hầu hết các trường hợp, đại diện đầu vào là một tập tin văn bản có chứa mã đáp ứng các yêu cầu kỹ thuật của một ngôn ngữ lập trình cao cấp nhất định. Các đại diện đầu ra thường là một bản dịch cấp thấp hơn của cùng một chương trình. Sự đại diện cấp thấp như vậy thường được đọc bằng phần cứng hoặc phần mềm, và hiếm khi bởi người . Điểm mấu chốt thường là các trình biên dịch biến đổi các chương trình từ dạng cấp cao, người có thể đọc được của họ sang dạng thấp hơn, có thể đọc được bằng máy tính.

 - Trong quá trình dịch, các trình biên dịch thường trải qua nhiều bước cải tiến hoặc tối ưu hóa để tận dụng lợi thế "hiểu biết" của chương trình và sử dụng các thuật toán khác nhau để nâng cao hiệu quả của mã. Như tôi đã đề cập, những tối ưu hóa này có khuynh hướng "tác dụng phụ" mạnh: chúng làm suy giảm nghiêm trọng khả năng đọc được của mã tạo ra. Mã trình biên dịch tạo ra chỉ đơn giản là không dùng để đọc bởi con người.

#### kiến trúc trình biên dịch

 - Trình biên dịch trung bình bao gồm ba thành phần cơ bản. font end có trách nhiệm giải mã văn bản chương trình gốc và đảm bảo rằng cú pháp của nó là chính xác và phù hợp với các thông số của ngôn ngữ. Trình tối ưu hoá cải thiện chương trình bằng cách này hay cách khác, trong khi vẫn giữ nguyên ý nghĩa ban đầu. Cuối cùng, back end có trách nhiệm tạo ra các nền tảng nhị phân cụ thể từ mã tối ưu hóa được phát ra bởi trình tối ưu hóa. Các phần sau thảo luận về từng thành phần này một cách sâu sắc.

#### FONT END

 - Quá trình biên dịch bắt đầu ở font end của trình biên dịch và bao gồm một số bước phân tích mã nguồn ngôn ngữ cấp cao. Biên dịch thường bắt đầu với một quá trình được gọi là *phân tích từ vựng* hoặc *quét*, trong đó trình biên dịch đi qua tệp nguồn và quét văn bản cho các thẻ bài cá nhân trong đó. Tokens là các ký hiệu văn bản tạo nên mã, do đó trong một dòng như: 

```
if (Remainder != 0)
```

 - Các ký hiệu nếu, (, Remainder, và! = Là tất cả các thẻ.Trong khi quét các mã số, các phân tích từ vựng xác nhận rằng các thẻ tạo ra "câu" hợp pháp phù hợp với các quy tắc của ngôn ngữ. Ví dụ, các lexical analyzer có thể kiểm tra xem các mã thông báo IF là theo sau bởi một (, đó là một yêu cầu trong một số ngôn ngữ. Cùng với mỗi từ, máy phân tích lưu giữ ý nghĩa của từ trong một ngữ cảnh cụ thể. Đây có thể được coi là một phiên bản rất đơn giản của cách thức con người phá vỡ các câu bằng các ngôn ngữ tự nhiên. Một câu được chia thành nhiều phần hợp lý, và các từ chỉ có thể mang ý nghĩa thực tế khi được đặt vào ngữ cảnh. Tương tự, phân tích từ vựng liên quan đến việc xác nhận tính hợp pháp của mỗi mã thông báo trong bối cảnh hiện tại và đánh dấu ngữ cảnh đó. Nếu một token được tìm thấy mà không phải là mong đợi trong bối cảnh hiện tại, trình biên dịch báo cáo một lỗi. Trình biên dịch FONT END của trình biên dịch có lẽ là một thành phần có ít liên quan nhất đến người đảo ngược, bởi vì nó chủ yếu là một bước chuyển đổi hiếm khi thay đổi ý nghĩa của chương trình theo bất kỳ cách nào-nó chỉ xác minh rằng nó là hợp lệ và chuyển nó sang trình bày trung gian của trình biên dịch

#### Đại diện Trung gian

 - Khi bạn nghĩ về nó, trình biên dịch là tất cả về đại diện. Vai trò chính của một nhà cung cấp dịch vụ là chuyển đổi mã từ một đại diện sang một đại diện khác. Trong quá trình, trình biên dịch phải tạo ra một biểu diễn riêng cho mã. Sự đại diện trung gian này (hay đại diện nội bộ, như đôi khi được gọi), rất hữu ích cho việc phát hiện bất kỳ lỗi mã nào, cải tiến mã và kết quả cuối cùng là tạo mã máy . 

 - Việc lựa chọn đúng cách trình bày trung gian của mã trong trình biên dịch là một trong những quyết định thiết kế quan trọng nhất của nhà thiết kế trình biên dịch. Việc bố trí nhiều phụ thuộc vào loại nguồn (ngôn ngữ cấp cao) trình biên dịch lấy như đầu vào, và loại đối tượng mã mà trình biên dịch spews ra. Một số đại diện trung gian có thể rất gần với một ngôn ngữ cấp cao và giữ lại nhiều cấu trúc ban đầu của chương trình. Thông tin như vậy có thể hữu ích nếu cải tiến nâng cao và tối ưu hóa được thực hiện trên mã.

 - Các trình biên dịch khác sử dụng các đại diện trung gian gần với mã ngôn ngữ lắp ráp mức thấp. Các biểu diễn như vậy thường chiếm nhiều cấu trúc cấp cao được nhúng trong mã ban đầu và phù hợp với các thiết kế trình biên dịch tập trung nhiều hơn vào các chi tiết cấp thấp của mã.Cuối cùng, các trình biên dịch sẽ không có hai hoặc nhiều đại diện trung gian, một cho mỗi giai đoạn trong quá trình biên dịch.

#### tối ưu hóa 

 - Việc có thể thực hiện tối ưu hóa là một trong những lý do chính mà người đảo ngược nên hiểu các trình biên dịch (lý do khác là hiểu được mức tối ưu hóa cấp mã được thực hiện ở back end). Hai mục tiêu chính cho việc tối ưu hoá thường là tạo mã hiệu suất cao nhất có thể hoặc tạo ra các chương trình nhị phân nhỏ nhất có thể. Hầu hết các trình biên dịch có thể cố gắng để kết hợp hai mục tiêu càng nhiều càng tốt. 

 - Tối ưu hóa diễn ra trong trình tối ưu hoá không phải là bộ xử lý cụ thể và là những cải tiến chung cho mã của chương trình gốc mà không liên quan đến nền tảng cụ thể mà chương trình được nhắm đến. Bất kể những tối ưu hóa cụ thể xảy ra, những người tối ưu hoá phải luôn luôn giữ được ý nghĩa chính xác của chương trình gốc và không thay đổi hành vi của nó theo bất kỳ cách nào. Các phần sau đây sẽ ngắn gọn thảo luận về các lĩnh vực khác nhau mà các nhà tối ưu hoá có thể cải thiện một chương trình. Cần lưu ý rằng một số tối ưu hoá ảnh hưởng mạnh đến tính dễ đọc của chương trình có thể đến từ công việc cụ thể của bộ vi xử lý diễn ra trong BACK END và không chỉ từ trình tối ưu hóa.

#### cấu trúc mã

 - Trình tối ưu hóa sửa đổi cấu trúc của mã để làm cho nó hiệu quả hơn trong khi vẫn giữ được ý nghĩa của nó. Ví dụ, vòng thường có thể được một phần hoặc hoàn toàn unrolled. Việc rút ra một vòng lặp có nghĩa là thay vì lặp đi lặp lại cùng một đoạn mã bằng cách sử dụng lệnh nhảy, mã chỉ đơn giản là sao chép sao cho bộ xử lý thực hiện nó nhiều lần. Điều này làm cho kết quả nhị phân lớn hơn, nhưng có lợi thế là hoàn toàn tránh phải quản lý một truy cập và gọi các nhánh có điều kiện (khá không hiệu quả - xem phần trên các đường dẫn của CPU sau này trong chương này). Cũng có thể bỏ một phần vòng lặp để số lần lặp lại được giảm đi bằng cách thực hiện nhiều lần lặp trong mỗi vòng lặp của vòng lặp.

 - Khi đi qua các khối chuyển đổi, trình biên dịch có thể xác định những gì sẽ là cách tiếp cận hiệu quả nhất để tìm kiếm các trường hợp chính xác trong thời gian chạy. Đây có thể là một bảng trực tiếp mà các khối riêng lẻ được truy cập sử dụng toán hạng hoặc sử dụng các kiểu tiếp cận tìm kiếm dựa trên cây khác nhau. 

 - Một ví dụ khác về tối ưu hóa cấu trúc mã là cách mà các vòng lặp được sắp xếp lại để làm cho chúng hiệu quả hơn. Xây dựng loop cao cấp phổ biến nhất là vòng lặp pretested, nơi điều kiện của vòng lặp được kiểm tra trước khi thân của vòng lặp được thực thi. Vấn đề với cấu trúc này là nó đòi hỏi nhảy thêm vô điều kiện thêm ở phần cuối của thân vòng để nhảy trở lại đầu vòng lặp (để so sánh, các vòng posttested chỉ có một lệnh đơn giản có điều kiện ở cuối vòng lặp , làm cho chúng hiệu quả hơn). Bởi vì điều này, nó là phổ biến cho tối ưu hóa để chuyển đổi vòng pretested sang vòng lặp posttested. Trong một số trường hợp, điều này đòi hỏi phải chèn một câu lệnh IF trước khi bắt đầu vòng lặp, để đảm bảo vòng lặp không được nhập khi tình trạng của nó không được thỏa mãn. Tối ưu hóa cấu trúc mã được thảo luận chi tiết hơn trong Phụ lục A.

#### loại bỏ phần thừa

 - Loại bỏ thừa là một yếu tố quan trọng trong lĩnh vực tối ưu hóa mã mà ít liên quan đến người đảo ngược. Các lập trình thường xuyên làm ra mã bao gồm phần dư thừa như lặp lại cùng một phép tính nhiều lần, gán các giá trị cho biến mà không bao giờ sử dụng chúng, và vân vân. Trình tối ưu hoá có các thuật toán tìm kiếm sự dư thừa và loại bỏ chúng.

 - Ví dụ, các lập trình viên thường để lại các biểu thức tĩnh bên trong vòng lặp, vốn là lãng phí bởi vì không cần tính toán nhiều lần chúng - chúng không bị ảnh hưởng bởi tiến trình của vòng lặp. Một trình tối ưu hóa tốt xác định các câu lệnh như vậy và di chuyển chúng tới một vùng ngoài vòng lặp để cải thiện hiệu quả của mã.

 - Trình tối ưu hoá cũng có thể sắp xếp số học con trỏ bằng cách tính toán hiệu quả địa chỉ của một mục trong một mảng hoặc cấu trúc dữ liệu một cách hiệu quả và đảm bảo rằng kết quả được lưu trữ để tính toán không được lặp lại nếu mục đó cần phải được truy cập lại sau trong mã.

#### BACK END

 - Một BACK END của trình biên dịch, đôi khi được gọi là bộ tạo mã, chịu trách nhiệm tạo mã mục tiêu cụ thể từ mã trung gian được tạo ra và xử lý trong các giai đoạn trước của quá trình biên dịch. Đây là nơi mà các đại diện trung gian "đáp ứng" ngôn ngữ mục tiêu cụ thể, mà thường là một số loại ngôn ngữ lắp ráp cấp thấp. Vì bộ tạo mã chịu trách nhiệm cho việc lựa chọn ngôn ngữ lắp ráp cụ thể, nên thường là thành phần duy nhất có đủ thông tin để áp dụng bất kỳ sự tối ưu hóa cụ thể nào về nền tảng. Điều này rất quan trọng bởi vì nhiều biến đổi làm cho mã trình biên dịch tạo ra mã ngôn ngữ lắp ráp khó đọc diễn ra ở giai đoạn này.

 - Sau đây là ba giai đoạn quan trọng nhất (ít nhất là theo quan điểm của chúng ta) diễn ra trong quá trình tạo mã:
 <ul>
 <li> **lựa chọn lệnh** : Đây là nơi mã từ đại diện trung gian được dịch sang các hướng dẫn dành riêng cho nền tảng. Việc lựa chọn từng hướng dẫn riêng lẻ là rất quan trọng đối với việc thực hiện chương trình tổng thể và yêu cầu trình biên dịch phải nhận thức được các đặc tính khác nhau của mỗi hướng dẫn.</li>
 <li> **phân bổ thanh ghi** : trong nhiều đại diện trung gian có một số lượng không giới hạn của thanh ghi có sẵn, để mỗi biến địa phương có thể được đặt trong một thanh ghi. Thực tế là bộ xử lý đích có một số lượng hạn chế các thanh ghi đã được phát trong quá trình tạo mã, khi trình biên dịch phải quyết định biến nào được đặt trong thanh ghi nào và biến nào phải được đặt trên stack.</li>
 <li> **Lập lịch trình** : Bởi vì hầu hết các bộ xử lý hiện đại có thể xử lý nhiều lệnh cùng một lúc, sự phụ thuộc dữ liệu giữa các hướng dẫn cá nhân trở thành một vấn đề. Điều này có nghĩa là nếu một lệnh thực hiện một thao tác và lưu trữ kết quả trong thanh ghi, thì ngay lập tức đọc từ thanh ghi đó theo hướng dẫn sau sẽ gây ra sự chậm trễ, bởi vì kết quả của thao tác đầu tiên có thể không có sẵn. Vì lý do này, trình tạo mã sử dụng các thuật toán lập lịch trình chỉ lệnh nền cụ thể để sắp xếp lại các hướng dẫn để cố gắng đạt được mức độ song song cao nhất có thể. Kết quả cuối cùng là * interleaved code *, trong đó hai chuỗi lệnh giao dịch với hai thứ riêng biệt được interleaved để tạo ra một chuỗi các hướng dẫn. Chúng ta sẽ thấy các chuỗi như vậy trong nhiều phiên đảo ngược trong cuốn sách này.</li>
 </ul>

#### tệp danh mục 

 - Một tệp liệt kê là tệp tin văn bản trình biên dịch tạo ra có chứa mã ngôn ngữ lắp ráp được trình biên dịch tạo ra. Đúng là thông tin này có thể thu được bằng cách tháo rời các tệp nhị phân do trình biên dịch tạo ra, nhưng một tệp danh sách cũng thuận tiện cho thấy cách mỗi đường dây lắp ráp bản đồ với mã nguồn gốc. Các tệp danh mục không phải là một công cụ đảo chiều hoàn toàn mà là một công cụ nghiên cứu được sử dụng khi cố gắng nghiên cứu hành vi của một trình biên dịch cụ thể bằng cách cấp mã số khác và quan sát đầu ra thông qua tệp liệt kê.

 - Hầu hết các trình biên dịch hỗ trợ tạo ra các tệp liệt kê trong quá trình biên dịch. Đối với một số trình biên dịch, chẳng hạn như GCC, đây là một phần tiêu chuẩn của quá trình biên dịch vì trình biên dịch không trực tiếp tạo ra một tệp tin đối tượng, mà thay vào đó tạo tệp ngôn ngữ lắp ráp sau đó được xử lý bởi một trình lắp ráp. Trong trình biên dịch như vậy, yêu cầu một tập tin danh sách chỉ có nghĩa là trình biên dịch không được xóa nó sau khi lắp ráp được thực hiện với nó. Trong các trình biên dịch khác (chẳng hạn như trình biên dịch Microsoft hoặc Intel), một tệp liệt kê là một tính năng tùy chọn phải được kích hoạt qua dòng lệnh.

#### trình biên dịch cụ thể 

 - Bất kỳ mẫu mã biên dịch nào được thảo luận trong cuốn sách này đã được tạo ra với một trong ba trình biên dịch (điều này không bao gồm mã của bên thứ ba đã bị đảo ngược trong cuốn sách):
 <ul>
 <li> **GCC and G++ version 3.3.1** : Trình biên dịch GNU C (GCC) và GNU C ++ Compiler (G ++) là những trình dịch mã nguồn mở phổ biến tạo ra mã cho một số lượng lớn các bộ vi xử lý khác nhau, bao gồm IA-32. Các trình biên dịch GNU (cũng có sẵn cho các ngôn ngữ bậc cao khác) thường được sử dụng bởi các nhà phát triển làm việc trên các nền tảng Unix như Linux, và hầu hết các nền tảng Unix thực sự được xây dựng bằng cách sử dụng chúng. Lưu ý rằng bạn cũng có thể viết mã cho Microsoft Windows sử dụng trình biên dịch GNU. Các trình biên dịch GNU có một công cụ tối ưu hóa mạnh mẽ thường cho kết quả tương tự như các trình biên dịch khác trong danh sách này. Tuy nhiên, các trình biên dịch GNU dường như không có một bộ tạo mã IA-32 đặc biệt mạnh mẽ, có lẽ vì khả năng tạo mã cho rất nhiều bộ xử lý khác nhau. Một mặt, điều này thường làm cho mã IA-32 tạo ra bởi chúng ít hiệu quả so với một số trình biên dịch phổ biến khác của IA-32. Mặt khác, từ quan điểm đảo chiều, điều này thực sự là một lợi thế bởi vì mã họ sản xuất thường dễ đọc hơn, ít nhất là so với mã do các trình biên dịch khác thảo luận ở đây.</li>
 <li> **Microsoft C/C++ Optimizing Compiler version 13.10.3077** : Microsoft Optimizing Compiler là một trong những trình biên dịch phổ biến nhất cho nền tảng Windows. Trình biên dịch này được vận chuyển với các phiên bản khác nhau của Microsoft Visual Studio, và phiên bản cụ thể được sử dụng trong suốt cuốn sách này là phiên bản được xuất bản với Microsoft Visual C ++ .NET 2003.</li>
 <li> **Intel C++ Compiler version 8.0** : Trình biên dịch C / C ++ của Intel được phát triển chủ yếu cho những người cần phải vắt kiệt hiệu suất tối đa tuyệt đối có thể từ bộ vi xử lý IA-32 của Intel. Trình biên dịch Intel có một giai đoạn tối ưu hóa tốt có vẻ như ngang bằng với hai trình biên dịch khác trong danh sách này, nhưng phần cuối của nó là nơi mà trình biên dịch Intel tỏa sáng. Intel không ngạc nhiên khi tập trung làm cho trình biên dịch này tạo mã IA-32 được tối ưu hóa cao, tính đến kiến trúc Intel NetBurst (và các kiến trúc Intel khác). Trình biên dịch Intel cũng hỗ trợ SSE tiên tiến, SSE2 và SSE3 mở rộng trong các bộ xử lý IA-32 hiện đại.</li>
 </ul>

#### môi trường thực thi.

 - Môi trường thực thi là thành phần thực sự chạy các chương trình. Đây có thể là một CPU hoặc một môi trường phần mềm như một máy ảo. Môi trường thi hành đặc biệt quan trọng đối với người đảo ngược vì kiến trúc của chúng thường ảnh hưởng đến cách chương trình được tạo ra và biên soạn, ảnh hưởng trực tiếp đến tính dễ đọc của mã và quá trình đảo chiều.

 - Các phần sau mô tả hai loại cơ bản của môi trường thực thi, đó là máy ảo và vi xử lý, và mô tả cách môi trường thực hiện của chương trình ảnh hưởng đến quá trình đảo chiều.

#### vitual machine 

 - Một số nền tảng phát triển phần mềm không sản xuất mã máy thực thi trực tiếp chạy trên một bộ xử lý. Thay vào đó, chúng tạo ra một số dạng đại diện trung gian của chương trình, hoặc bytecode. Bytecode này sau đó được đọc bởi một chương trình đặc biệt trên máy của người dùng, thực hiện chương trình trên bộ vi xử lý cục bộ. Chương trình này được gọi là một máy ảo. Các máy ảo luôn là bộ xử lý cụ thể, có nghĩa là một máy ảo cụ thể chỉ chạy trên một nền tảng cụ thể. Tuy nhiên, nhiều định dạng bytecode có nhiều máy ảo cho phép chạy cùng một chương trình bytecode trên các nền tảng khác nhau. 

 - Hai kiến trúc máy ảo thông thường là Java Virtual Machine (JVM) chạy các chương trình Java và Common Language Runtime (CLR) chạy các ứng dụng Microsoft .NET.

 - Các chương trình chạy trên máy ảo có một số lợi ích đáng kể so với các chương trình gốc thực hiện trực tiếp trên phần cứng cơ bản:
 <ul>
 <li> **nền tảng tách biệt** : Bởi vì chương trình tiếp cận người dùng cuối trong một đại diện chung mà không phải là máy cụ thể, nó về mặt lý thuyết có thể được thực hiện trên bất kỳ nền tảng máy tính nào mà môi trường thực thi tương thích tồn tại. Nhà cung cấp phần mềm không phải lo lắng về các vấn đề tương thích nền tảng (ít nhất về mặt lý thuyết) — môi trường thực thi đứng giữa chương trình và hệ thống và gói gọn mọi khía cạnh cụ thể cho nền tảng.</li>
 <li> **Chức năng nâng cao**: Khi một chương trình đang chạy dưới một máy ảo, nó có thể (và thường làm) được hưởng lợi từ một loạt các tính năng nâng cao hiếm khi được tìm thấy trên các bộ vi xử lý silicon thực. Điều này có thể bao gồm các tính năng như thu gom rác, là một hệ thống tự động theo dõi việc sử dụng tài nguyên và tự động giải phóng các đối tượng bộ nhớ khi chúng không còn được sử dụng nữa. Một tính năng nổi bật khác là safety runtime: vì các máy ảo có thông tin kiểu dữ liệu chính xác trên chương trình đang được thực hiện, nó có thể xác minh được loại an toàn được duy trì trong suốt chương trình. Một số máy ảo cũng có thể theo dõi truy cập bộ nhớ và đảm bảo rằng chúng là hợp pháp. Do máy ảo biết chính xác độ dài của mỗi khối bộ nhớ và có thể theo dõi việc sử dụng nó trong ứng dụng, nó có thể dễ dàng phát hiện các trường hợp chương trình cố gắng đọc hoặc ghi ngoài phần cuối của khối bộ nhớ, v.v.</li>
 </ul>

#### Bytecodes 

 - Điều thú vị về các máy ảo là chúng hầu như luôn có định dạng bytecode riêng của chúng. Về cơ bản, đây là ngôn ngữ cấp thấp giống như ngôn ngữ lắp ráp của bộ xử lý phần cứng (chẳng hạn như ngôn ngữ lắp ráp IA-32). Sự khác biệt của nó là cách mã nhị phân được thực hiện như thế nào. Không giống như các chương trình nhị phân thông thường, mỗi lệnh được giải mã và được thực thi bởi phần cứng, các máy ảo thực hiện giải mã riêng của chúng trong các chương trình nhị phân. Đây là những gì cho phép kiểm soát chặt chẽ như vậy trên tất cả mọi thứ mà chương trình làm; bởi vì mỗi lệnh được thực thi phải đi qua máy ảo, VM có thể giám sát và kiểm soát bất kỳ hoạt động nào được thực hiện bởi chương trình.

**Sự khác biệt giữa mã byte bytecode và bộ xử lý nhị phân thông thường có chút mờ trong vài năm qua. Một số công ty đã phát triển bộ vi xử lý bytecode có thể tự chạy ngôn ngữ bytecode, trước đây chỉ được hỗ trợ trên các máy ảo. Trong Java, ví dụ, có những công ty như Imsys và aJile cung cấp “bộ xử lý thực thi trực tiếp” trực tiếp thực thi mã byte Java mà không cần sử dụng máy ảo.**

#### biên dịch

 - Cách tiếp cận ban đầu để triển khai các máy ảo là sử dụng các trình thông dịch. trinhg biên dịch là các chương trình đọc mã byte bytecode của chương trình thực thi và giải mã từng lệnh và "thực thi" nó trong môi trường ảo được triển khai trong phần mềm. Điều quan trọng là phải hiểu rằng không chỉ các lệnh này không được thực hiện trực tiếp trên bộ xử lý, mà hơn nữa dữ liệu được chương trình bytecode truy cập cũng được quản lý bởi trình thông dịch. Điều này có nghĩa là chương trình bytecode sẽ không có quyền truy cập trực tiếp vào thanh ghi của máy chủ lưu trữ. Bất kỳ "thanh ghi" nào được truy cập bởi bytecode sẽ thường phải được ánh xạ tới bộ nhớ bởi trình thông dịch.

 - Trình biên dịch có một nhược điểm chính: hiệu suất. Bởi vì mỗi lệnh được giải mã riêng và được thực hiện bởi một chương trình chạy dưới CPU thực, chương trình cuối sẽ chạy chậm hơn đáng kể so với khi nó chạy trực tiếp trên CPU của máy chủ. Lý do cho điều này trở nên rõ ràng khi người ta xem xét số lượng công việc mà trình biên dịch phải thực hiện để thực thi một lệnh bytecode cấp cao.

 - Đối với mỗi lệnh, trình thông dịch phải nhảy đến một hàm đặc biệt hoặc vùng mã tương ứng với nó, xác định toán hạng liên quan và sửa đổi trạng thái hệ thống để phản ánh các thay đổi. Ngay cả khi thực hiện tốt nhất một trình biên dịch vẫn cho kết quả trong mỗi lệnh bytecode sẽ được dịch sang hàng chục lệnh trên CPU vật lý. Điều này có nghĩa rằng các chương trình giải mã chạy các lệnh có cường độ chậm hơn so với các đối tác được biên dịch của chúng.

#### Just-in-Time Compilers

 - Triển khai máy ảo hiện đại thường tránh sử dụng trình thông dịch vì các vấn đề hiệu suất được mô tả ở trên. Thay vào đó, họ sử dụng các trình biên dịch đơn giản, hoặc các JiTs. Just-in-time compilation là một cách tiếp cận thay thế để chạy các chương trình bytecode mà không có tác động hiệu suất liên quan đến trình biên dịch. Ý tưởng là lấy đoạn trích của chương trình bytecode khi chạy và biên dịch chúng thành ngôn ngữ máy của bộ xử lý gốc trước khi chạy chúng. Các đoạn mã này sau đó được thực thi tự nhiên trên CPU của máy chủ. Đây thường là một quá trình liên tục trong đó các đoạn mã bytecode được biên dịch theo yêu cầu, bất cứ khi nào chúng được yêu cầu .

#### Chiến lược đảo ngược

 - Việc đảo ngược các chương trình bytecode thường là một trải nghiệm hoàn toàn khác so với các chương trình thực thi nguyên gốc thông thường. Đầu tiên và quan trọng nhất, hầu hết các ngôn ngữ bytecode đều chi tiết hơn nhiều so với các mã nguồn gốc của chúng. Ví dụ, Microsoft .NET chứa thông tin kiểu dữ liệu có chi tiết cao được gọi là siêu dữ liệu. Siêu dữ liệu cung cấp thông tin về các lớp, các tham số chức năng, các loại biến cục bộ và hơn thế nữa. 

 - Có loại thông tin này hoàn toàn thay đổi trải nghiệm đảo ngược bởi vì nó mang chúng ta đến gần hơn với bản trình bày cao cấp ban đầu của chương trình. Trong thực tế, thông tin này cho phép tạo ra các trình giải mã có hiệu quả cao có thể tái tạo lại các biểu diễn ngôn ngữ cấp cao đáng kể có thể đọc được từ các tệp thực thi bytecode. Tình trạng này là đúng cho cả hai chương trình Java và .NET, và nó trình bày một vấn đề cho các nhà cung cấp phần mềm làm việc trên các nền tảng đó, những người có thời gian bảo vệ các tập tin thực thi của họ không bị đảo ngược một cách dễ dàng. Giải pháp trong hầu hết các trường hợp là sử dụng các obfuscators — các chương trình cố gắng loại bỏ càng nhiều thông tin nhạy cảm khỏi tệp thực thi càng tốt (trong khi vẫn giữ chức năng của chương trình).

 - Tùy thuộc vào nền tảng cụ thể và sự tích cực của một tập tin thực thi, các trình đảo ngược có hai lựa chọn: chúng có thể sử dụng trình biên dịch ngược để tái tạo một biểu diễn mức cao của chương trình đích hoặc họ có thể học ngôn ngữ cấp thấp nguyên bản trong đó chương trình được trình bày và chỉ cần đọc mã đó và cố gắng xác định hình dáng và mục đích của chương trình. May mắn thay, các ngôn ngữ bytecode này thường khá dễ giải quyết vì chúng không ở mức độ thấp như ngôn ngữ lắp ráp mà là khoảng trung bình giữa nó vàbộ xử lý gốc. Chương 12 giới thiệu về nền tảng .NET của Microsoft và ngôn ngữ mẹ đẻ của nó, Microsoft Intermediate Language (MSIL), và trình bày cách đảo ngược các chương trình được viết cho nền tảng .NET.

#### Môi trường thực thi phần cứng trong bộ vi xử lý hiện đại

 - Vì cuốn sách này tập trung chủ yếu vào quá trình đảo ngược cho các chương trình IA-32 nguyên bản, nên hãy xem xét cách mã được thực thi bên trong các bộ xử lý này để xem bạn có thể khai thác thông tin đó bằng cách nào đó để lợi cho bạn trong khi đảo ngược hay không.

 - Trong những ngày đầu của bộ vi xử lý, mọi thứ trở nên đơn giản hơn nhiều. Một bộ vi xử lý là một tập hợp các mạch kỹ thuật số có thể thực hiện một loạt các hoạt động và được kiểm soát bằng cách sử dụng mã máy đã được đọc từ bộ nhớ. Thời gian chạy của bộ xử lý bao gồm đơn giản là một chuỗi lặp liên tục đọc một lệnh từ bộ nhớ, giải mã nó và kích hoạt mạch chính xác để thực hiện thao tác được chỉ định trong mã máy. Điều quan trọng cần nhận ra là việc thực thi hoàn toàn nối tiếp. Do nhu cầu về các bộ vi xử lý phải nhanh hơn và linh hoạt hơn, các nhà thiết kế vi xử lý buộc phải đưa vào sử dụng một loạt các kỹ thuật song song.

 - Vấn đề là khả năng tương thích ngược luôn là một vấn đề. Ví dụ, phiên bản mới hơn của bộ vi xử lý IA-32 vẫn phải hỗ trợ tập lệnh IA-32 ban đầu. Thông thường, đây không phải là vấn đề, nhưng các nhà thiết kế hiện đại có hỗ trợ đáng kể cho việc thực hiện song song, rất khó để đạt được xem xét rằng tập lệnh không được thiết kế rõ ràng để hỗ trợ nó. Bởi vì hướng dẫn được thiết kế để chạy cái khác và không theo bất kỳ cách nào khác, các lệnh tuần tự thường có sự phụ thuộc lẫn nhau để ngăn chặn sự song song. Chiến lược chung được sử dụng bởi các bộ xử lý IA-32 hiện đại để đạt được tính song song là chỉ cần thực hiện hai hoặc nhiều lệnh cùng một lúc. Các vấn đề bắt đầu khi một lệnh phụ thuộc vào thông tin do lệnh khác tạo ra. Trong những trường hợp như vậy, các hướng dẫn phải được thực hiện theo thứ tự ban đầu của chúng, để duy trì chức năng của mã.

 - Vì những hạn chế này, các trình biên dịch hiện đại sử dụng vô số các kỹ thuật để tạo mã có thể được thực hiện để chạy hiệu quả nhất có thể trên các bộ vi xử lý hiện đại. Điều này tự nhiên có tác động mạnh đến khả năng đọc của mã tháo rời trong khi đảo chiều. Hiểu được lý do đằng sau các kỹ thuật tối ưu hóa như vậy có thể giúp bạn giải mã các mã đã được tối ưu .

 - Các phần sau đây thảo luận về kiến trúc chung của bộ vi xử lý IA-32 hiện đại và cách chúng đạt được tính song song và thông lượng lệnh cao

> 	Chủ đề này là tùy chọn và được thảo luận ở đây vì nó luôn luôn là tốt nhất để biết lý do tại sao mọi thứ như họ đang có. Trong trường hợp này, có một sự hiểu biết chung về lý do tại sao trình tối ưu hóa mã IA-32 được sắp xếp theo cách này có thể hữu ích cho bạn khi cố gắng giải mã ý nghĩa của nó.**

> **IA-32 COMPATIBLE PROCESSORS**
> Trong những năm qua, nhiều công ty đã cố gắng thâm nhập vào thị trường bộ vi xử lý hấp dẫn IA-32 (đã hoàn toàn bị chi phối bởi Tập đoàn Intel) bằng cách tạo ra các bộ xử lý tương thích IA-32. Chiến lược này thường là cung cấp các bộ xử lý có giá tốt hơn tương thích 100% với bộ vi xử lý IA-32 của Intel và cung cấp hiệu suất tương đương hoặc được cải thiện. AMD (Advanced Micro Devices) là công ty thành công nhất trên thị trường này, với thị phần trung bình hơn 15% trong thị trường vi xử lý IA-32. 

> Trong khi tìm hiểu về ngôn ngữ lắp ráp IA-32, thường không cần phải lo lắng về các thương hiệu khác vì khả năng tương thích tuyệt vời của chúng với việc triển khai Intel. Ngay cả mã được tối ưu hóa đặc biệt cho kiến trúc NetBurst của Intel thường chạy rất tốt trên các triển khai khác như bộ vi xử lý AMD, do đó trình biên dịch hiếm khi phải lo lắng về việc tối ưu hóa cụ thể cho bộ vi xử lý không phải của Intel.

> Một tính năng đặc biệt của AMD là 3DNow! tập lệnh. 3DNow! định nghĩa một tập hợp các chỉ lệnh SIMD (hướng dẫn nhiều dữ liệu) có thể thực hiện nhiều thao tác dấu phẩy động trên mỗi chu kỳ đồng hồ. 3DNow! đứng cạnh tranh trực tiếp với SSE, SSE2 và SSE3 của Intel (Tiện ích mở rộng SIMD trực tuyến). Ngoài việc hỗ trợ 3DNow của riêng mình! bộ hướng dẫn, bộ vi xử lý AMD cũng hỗ trợ các phần mở rộng SSE của Intel để duy trì khả năng tương thích. Không cần phải nói, bộ vi xử lý Intel không hỗ trợ 3DNow.


#### Intel NetBurst

 - Kiến trúc Intel NetBurst là môi trường thực thi hiện tại cho nhiều bộ vi xử lý IA-32 hiện đại của Intel. Việc hiểu kiến trúc cơ bản của NetBurst là quan trọng vì nó giải thích lý do đằng sau các hướng dẫn tối ưu hóa được sử dụng bởi hầu hết các bộ tạo mã IA-32 ở bên ngoài.

#### μops (Micro-Ops)

 - Bộ xử lý IA-32 sử dụng microcode để thực hiện từng lệnh được bộ xử lý hỗ trợ. Microcode thực chất là một lớp lập trình khác nằm trong bộ vi xử lý. Điều này có nghĩa rằng bản thân bộ xử lý chứa một lõi nguyên thủy hơn nhiều, chỉ có khả năng thực hiện các hoạt động khá đơn giản (mặc dù ở tốc độ cực cao). Để thực hiện các lệnh IA-32 tương đối phức tạp, bộ vi xử lý có microcode ROM , chứa các chuỗi vi mã cho mọi lệnh trong tập lệnh.
 - Quá trình tìm kiếm mã microcode liên tục từ ROM có thể tạo ra các tắc nghẽn hiệu suất đáng kể, vì vậy các bộ vi xử lý IA-32 sử dụng bộ đệm truy vấn thực thi chịu trách nhiệm lưu bộ nhớ đệm các mã vi mô của các lệnh được thực hiện thường xuyên.

#### Pipelines

 - Về cơ bản, một đường ống CPU giống như một dây chuyền lắp ráp nhà máy để giải mã và thực hiện các hướng dẫn chương trình. Một hướng dẫn đi vào đường ống và được chia nhỏ thành một số tác vụ cấp thấp sẽ được bộ xử lý xử lý.
 	Trong các bộ xử lý NetBurst, đường ống sử dụng ba giai đoạn chính:
 	<ul>
 	<li>1. Front end: Chịu trách nhiệm giải mã từng lệnh và tạo chuỗi các μops đại diện cho mỗi lệnh. Những μops này sau đó được đưa vào Out of Order Core.>/li>
 	<li>2. Out of Order Core: Thành phần này nhận chuỗi các μοps từ "FRONT END" và sắp xếp lại chúng dựa trên sự sẵn có của các tài nguyên khác nhau của bộ xử lý. Ý tưởng là sử dụng các nguồn lực sẵn có càng tích cực càng tốt để đạt được tính song song. Khả năng làm điều này phụ thuộc rất nhiều vào mã ban đầu được nạp vào "FRONT END". Với điều kiện thích hợp, lõi sẽ thực sự phát ra nhiều μops trên mỗi chu kỳ đồng hồ.</li>
 	<li>3. Retirement section: Phần cuối chủ yếu chịu trách nhiệm đảm bảo rằng thứ tự ban đầu của các hướng dẫn trong chương trình được bảo toàn khi áp dụng các kết quả của việc thực hiện không theo thứ tự.</li>
 	</ul>

 - Về mặt thực thi hoạt động thực tế, kiến trúc cung cấp bốn cổng thực thi (mỗi cổng có đường dẫn riêng) chịu trách nhiệm thực hiện các hướng dẫn thực tế. Mỗi đơn vị có các khả năng khác nhau, như trong Hình 2.4.

![2.4](https://i.imgur.com/2a6RWLU.png) 

![2.4.1](https://i.imgur.com/xjtiJ0U.png)

![2.4.2](https://i.imgur.com/Ch75DYE.png)

**hình 2.4** các cổng và các đơn vị thực thi riêng lẻ trong các bộ vi xử lý Intel NetBurst

 - Lưu ý cách cổng 0 và cổng 1 đều có ALU tốc độ gấp đôi (đơn vị logic số học). Đây là một khía cạnh quan trọng của tối ưu hóa IA-32 vì nó có nghĩa là mỗi ALU thực sự có thể thực hiện hai phép toán trong một chu kỳ xung nhịp đơn. Ví dụ, có thể thực hiện tối đa bốn phép cộng hoặc phép trừ trong một chu kỳ đồng hồ đơn (hai trong mỗi ALU tốc độ kép). Mặt khác, các hoạt động dấu phẩy động non-SIMD được đảm bảo nhiều để có ít nhất một chu kỳ vì chỉ có một đơn vị thực sự thực hiện các phép toán dấu phẩy động (và một đơn vị khác di chuyển dữ liệu giữa bộ nhớ và ngăn xếp FPU).

 - Hình 2.4 có thể giúp làm sáng tỏ các lệnh và thuật toán được sử dụng bởi các trình biên dịch nhận thức NetBurst, bởi vì nó cung cấp một lý do cho một hiện tượng nào đó mà chúng ta sẽ thấy sau này trong các trình tự tạo mã bởi trình biên dịch.

 - Hầu hết các trình biên dịch kết nối IA-32 hiện đại có thể được coi là NetBurstaware, theo nghĩa là chúng đưa kiến trúc NetBurst vào trong quá trình tạo mã. Điều này sẽ được hiển nhiên trong nhiều mẫu được trình bày trong cuốn sách này.

#### Branch Prediction

 - Một vấn đề quan trọng với phương pháp pipelined được mô tả trước đó đã làm với việc thực thi các nhánh. Vấn đề là các bộ vi xử lý có đường ống sâu phải luôn biết hướng dẫn nào sẽ được thực hiện tiếp theo. Thông thường, bộ vi xử lý chỉ đơn giản là lấy lệnh tiếp theo từ bộ nhớ bất cứ khi nào có chỗ cho nó, nhưng điều gì sẽ xảy ra khi có một nhánh có điều kiện trong mã?

 - Các nhánh có điều kiện là một vấn đề bởi vì thường kết quả của chúng không được biết tại thời điểm lệnh tiếp theo phải được tìm nạp. Một tùy chọn sẽ đơn giản là chờ trước khi xử lý các hướng dẫn hiện tại trong đường ống cho đến khi thông tin về việc liệu chi nhánh được thực hiện hay không có sẵn. Điều này sẽ có tác động bất lợi đến hiệu suất vì bộ vi xử lý chỉ hoạt động hết công suất khi đường ống đầy. Việc nạp lại đường ống sẽ mất một số lượng đáng kể chu kỳ đồng hồ, tùy thuộc vào độ dài của đường ống và các yếu tố khác.

 - Giải pháp cho những vấn đề này là thử và dự đoán kết quả của từng nhánh có điều kiện. Dựa trên dự đoán này, bộ xử lý sẽ điền vào đường ống với các hướng dẫn được đặt ngay sau lệnh nhánh (khi nhánh không được dự kiến thực hiện) hoặc từ địa chỉ đích của nhánh (khi nhánh được dự kiến sẽ được thực hiện). Một dự đoán bị nhỡ thường tốn kém và yêu cầu toàn bộ đường ống bị làm trống.

 - Chiến lược dự đoán chung là các nhánh nhảy ngược chuyển sang hướng dẫn trước đó luôn được dự kiến sẽ được thực hiện bởi vì chúng thường được sử dụng trong các vòng lặp, trong đó mỗi lần lặp lại sẽ có một bước nhảy và lần duy nhất không được thực hiện đó là lần lặp lại cuối cùng. Các nhánh chuyển tiếp (thường được sử dụng trong các câu lệnh "if") được giả định là không được thực hiện.

 - Để cải thiện khả năng dự đoán của bộ vi xử lý, bộ xử lý IA-32 sử dụng bộ đệm theo dõi chi nhánh (BTB) ghi lại kết quả của các lệnh rẽ nhánh mới nhất được xử lý. Bằng cách này, khi gặp phải một nhánh , nó được tìm kiếm trong BTB. Nếu tìm thấy một mục, bộ xử lý sẽ sử dụng thông tin đó để dự đoán nhánh.

#### kết luận.

 - Trong chương này, chúng tôi đã giới thiệu khái niệm về phần mềm cấp thấp và đi qua một số tài liệu cơ bản cần thiết cho các chương trình kỹ thuật đảo ngược thành công. Chúng tôi đã đề cập đến các khái niệm phần mềm cấp cao cơ bản và cách chúng dịch sang thế giới cấp thấp và giới thiệu ngôn ngữ lắp ráp, ngôn ngữ bản địa của thế giới đảo ngược. Ngoài ra, chúng tôi đã đề cập đến một số chủ đề cấp thấp hơn về lõi cứng thường ảnh hưởng đến quy trình kỹ thuật đảo ngược, chẳng hạn như các trình biên dịch và môi trường thực thi. Chương tiếp theo cung cấp một giới thiệu về một số tài liệu nền bổ sung và tập trung vào các nguyên tắc cơ bản của hệ điều hành.


## CHƯƠNG 3: Windows Fundamentals

 - Hệ điều hành đóng một vai trò quan trọng trong việc đảo chiều. Đó là vì các chương trình được tích hợp chặt chẽ với các hệ điều hành và rất nhiều thông tin có thể được thu thập bằng cách thăm dò giao diện này. Hơn nữa, dòng cuối cùng của mỗi chương trình là trong giao tiếp với thế giới bên ngoài (chương trình nhận dữ liệu đầu vào và đầu ra của người dùng trên màn hình, ghi vào một tệp, vv), có nghĩa là xác định và hiểu các điểm cầu nối giữa các chương trình ứng dụng và hệ điều hành là rất quan trọng.

 - Chương này giới thiệu kiến trúc của các thế hệ mới nhất của hệ điều hành Microsoft Windows, là hệ điều hành được sử dụng trong suốt cuốn sách này. Một số tài liệu này khá cơ bản. Nếu bạn cảm thấy hoàn toàn thoải mái với các hệ điều hành nói chung và với kiến trúc Windows nói riêng, hãy bỏ qua chương này.

 - Điều quan trọng là nhận ra rằng cuộc thảo luận này thực sự là một tổng quan ngắn gọn về thông tin có thể điền vào một số sách dày. Tôi đã cố gắng làm cho nó hoàn chỉnh nhất có thể và được tập trung vào việc đảo chiều nhất có thể. Nếu bạn cảm thấy như thể bạn cần thêm thông tin về một số chủ đề được thảo luận trong chương này, tôi đã liệt kê một vài nguồn bổ sung ở cuối chương này.

### Các thành phần và kiến trúc cơ bản

 - Trước khi đi vào chi tiết về cách Windows hoạt động, hãy bắt đầu bằng cách xem nhanh cách nó phát triển theo kiến trúc hiện tại của nó và bằng cách liệt kê các tính năng cơ bản nhất của Windows.

#### sơ lược lịch sử.

 - Như bạn có thể đã biết, đã từng có hai hệ điều hành khác nhau được gọi là Windows: Windows và Windows NT. Có Windows, được mang nhãn hiệu Windows 95, Windows 98 và Windows Me và là hậu duệ của các phiên bản Windows 16 bit cũ. Windows NT được đặt tên là Windows 2000 và gần đây hơn là Windows XP và Windows Server 2003. Windows NT là một thiết kế gần đây hơn mà Microsoft bắt đầu vào đầu những năm 1990. Windows NT được thiết kế từ nền tảng như một hệ điều hành có khả năng bộ nhớ ảo, đa luồng và đa xử lý 32 bit, làm cho nó trở nên phù hợp hơn để sử dụng với phần cứng và phần mềm hiện đại.

 - Cả hai hệ điều hành đều tương thích với API Win32, để làm cho các ứng dụng chạy trên cả hai hệ điều hành. Năm 2001, Microsoft cuối cùng đã quyết định loại bỏ sản phẩm Windows cũ (điều này đáng lẽ đã xảy ra sớm hơn nhiều trong quan điểm của tôi) và chỉ cung cấp các hệ thống dựa trên NT. Phiên bản Windows NT công cộng, tiêu dùng chung đầu tiên là Windows XP, cung cấp một cải tiến lớn cho người dùng Windows 9x (và một sự cải thiện đáng kể cho người dùng của người tiền nhiệm dựa trên NT-Windows 2000). Hệ điều hành được mô tả trong chương này về cơ bản là Windows XP, nhưng hầu hết các cuộc thảo luận đều đề cập đến các khái niệm cơ bản đã thay đổi rất ít giữa Windows NT 4.0 (được phát hành vào năm 1996) và Windows Server 2003. các tài liệu trong chương này sẽ có liên quan ngang nhau với bản phát hành Windows sắp tới (hiện có tên mã là "Longhorn").

#### tính năng.

 - Sau đây là các tính năng cơ bản của kiến trúc Windows NT.
 **Kiến trúc 32 bit thuần túy** Bây giờ việc chuyển đổi sang tính toán 64-bit đã là một cách tốt hơn điều này nghe có vẻ không nhiều, nhưng Windows NT là một môi trường tính toán 32-bit thuần túy, không có các dấu hiệu cũ 16-bit. Các phiên bản hiện tại của hệ điều hành cũng có sẵn trong các phiên bản 64 bit.
 
 **Hỗ trợ bộ nhớ ảo** Trình quản lý bộ nhớ của Windows NT sử dụng một mô hình bộ nhớ ảo toàn diện. Bộ nhớ ảo sẽ được thảo luận chi tiết sau trong chương này.

 **Di động** Không giống như sản phẩm Windows ban đầu, Windows NT được viết bằng sự kết hợp của C và C ++, có nghĩa là nó có thể được biên dịch lại để chạy trên các nền tảng xử lý khác nhau. Ngoài ra, bất kỳ truy cập phần cứng vật lý nào cũng đi qua Lớp trừu tượng phần cứng đặc biệt (HAL), cách ly hệ thống này với phần cứng và giúp dễ dàng chuyển hệ thống sang các nền tảng phần cứng mới.

 **đa luồng** Windows NT là một hệ thống đa luồng, được ưu tiên hoàn toàn. Trong khi đúng là các phiên bản sau của sản phẩm Windows ban đầu cũng đa luồng, chúng vẫn chứa các thành phần không cần thiết, chẳng hạn như triển khai 16-bit của USER và GDI (các thành phần GUI của Windows). Những thành phần này có ảnh hưởng xấu đến khả năng đạt được sự tương tác của các hệ thống đó.

 **có khả năng đa xử lý** Hạt nhân Windows NT có khả năng đa xử lý, có nghĩa là nó phù hợp hơn với các môi trường tính toán hiệu năng cao như các máy chủ trung tâm dữ liệu lớn và các ứng dụng chuyên sâu CPU khác.

 **bảo mật** Không giống như các phiên bản cũ của Windows, Windows NT được thiết kế với sự bảo mật. Mỗi đối tượng trong hệ thống có một Danh sách điều khiển truy cập liên quan (ACL) xác định người dùng nào được phép thao tác nó. Hệ thống tệp Windows NT (NTFS) cũng hỗ trợ ACL cho từng tệp riêng lẻ và hỗ trợ mã hóa các tệp riêng lẻ hoặc toàn bộ tệp.

 **Tương thích** Windows NT tương thích hợp lý với các ứng dụng cũ hơn và có khả năng chạy các ứng dụng Windows 16 bit và một số ứng dụng DOS. Các ứng dụng cũ được thực thi trong một máy ảo riêng biệt, nơi chúng không thể gây nguy hiểm cho phần còn lại của hệ thống.

#### Phần cứng được hỗ trợ

 - Ban đầu, Windows NT được thiết kế như một hệ điều hành đa nền tảng, và được phát hành cho một số kiến trúc bộ vi xử lý, bao gồm IA-32, DEC Alpha và một số khác. Với các phiên bản gần đây của hệ điều hành, nền tảng 32 bit được hỗ trợ duy nhất là IA-32, nhưng Microsoft hiện cũng hỗ trợ các kiến trúc 64 bit như AMD64, Intel IA-64 và Intel EMT64.


### Quản lý bộ nhớ

 - Thảo luận này dành riêng cho các phiên bản Windows 32 bit. Thực tế là các phiên bản Windows 64 bit có sự khác biệt đáng kể so với quan điểm đảo ngược, bởi vì các bộ vi xử lý 64 bit (bất kể kiến trúc cụ thể nào) sử dụng một ngôn ngữ lắp ráp khác. Việc tập trung hoàn toàn vào các phiên bản Windows 32 bit có ý nghĩa bởi vì cuốn sách này chỉ đề cập đến ngôn ngữ lắp ráp IA-32. Dường như nó vẫn sẽ mất hệ thống 64-bit một vài năm để trở thành một mặt hàng. Tôi hứa tôi sẽ cập nhật cuốn sách này khi điều đó xảy ra!


#### Virtual Memory and Paging

 - Bộ nhớ ảo là một khái niệm cơ bản trong các hệ điều hành hiện đại. Ý tưởng là thay vì cho phép phần mềm truy cập trực tiếp vào bộ nhớ vật lý, bộ vi xử lý, kết hợp với hệ điều hành, tạo ra một lớp vô hình giữa phần mềm và bộ nhớ vật lý. Đối với mọi truy cập bộ nhớ, bộ vi xử lý sẽ hỏi một bảng đặc biệt được gọi là bảng "trang" cho biết quá trình mà địa chỉ bộ nhớ vật lý thực sự sử dụng. Tất nhiên, sẽ không thực tế nếu có một mục nhập bảng cho mỗi byte bộ nhớ (một bảng như vậy sẽ lớn hơn tổng bộ nhớ vật lý sẵn có), do đó, các bộ vi xử lý chia bộ nhớ thành các trang.

 - Trang chỉ là các khối bộ nhớ có kích thước cố định; mỗi mục nhập trong bảng trang đề với một trang bộ nhớ. Kích thước thực tế của một trang bộ nhớ khác nhau giữa các kiến trúc bộ vi xử lý và một số kiến trúc hỗ trợ nhiều kích thước trang. Bộ vi xử lý IA-32 thường sử dụng các trang 4K, mặc dù chúng cũng hỗ trợ các trang 2 MB và 4 MB. Đối với hầu hết các phần Windows sử dụng các trang 4K, vì vậy bạn thường có thể xem đó là kích thước trang mặc định.

 - Khi lần đầu tiên suy nghĩ về khái niệm này, bạn có thể không thấy ngay những lợi ích của việc sử dụng một bảng trang. Có một số ưu điểm, nhưng điều quan trọng nhất là nó cho phép tạo ra nhiều không gian địa chỉ. Không gian địa chỉ là một bảng trang riêng biệt chỉ cho phép truy cập vào bộ nhớ phù hợp với chương trình hoặc quy trình hiện tại. Bởi vì quá trình ngăn ứng dụng truy cập vào bảng trang, nên không thể thực hiện quá trình phá vỡ ranh giới này. Khái niệm về nhiều không gian địa chỉ là một tính năng cơ bản trong các hệ điều hành hiện đại, bởi vì nó đảm bảo rằng các chương trình được phân lập hoàn toàn với nhau và mỗi quá trình có "sandbox" nhỏ của riêng nó để chạy.

 - Ngoài không gian địa chỉ, sự tồn tại của một bảng trang cũng có nghĩa là nó rất dễ dàng để hướng dẫn bộ xử lý thực thi các quy tắc nhất định về cách truy cập bộ nhớ. Ví dụ, các mục bảng trang thường có một bộ cờ để xác định các thuộc tính nhất định liên quan đến mục nhập cụ thể, chẳng hạn như nó có thể truy cập được từ chế độ không có đặc quyền hay không. Điều này có nghĩa là mã hệ điều hành thực sự có thể nằm trong không gian địa chỉ của process và chỉ cần đặt cờ trong các mục trong bảng trang để hạn chế ứng dụng không bao giờ truy cập dữ liệu nhạy cảm của hệ điều hành. 

 - Điều này đưa chúng ta đến các khái niệm cơ bản về chế độ hạt nhân so với chế độ người dùng. Chế độ Kernel về cơ bản là thuật ngữ Windows cho chế độ xử lý đặc quyền và thường được sử dụng để mô tả mã chạy trong chế độ đặc quyền hoặc bộ nhớ chỉ có thể truy cập trong khi bộ xử lý ở chế độ đặc quyền. Chế độ người dùng là chế độ không cố định: khi hệ thống ở chế độ người dùng, nó chỉ có thể chạy mã chế độ người dùng và chỉ có thể truy cập bộ nhớ chế độ người dùng.

#### Paging

 - Phân trang là một quá trình trong đó các vùng bộ nhớ tạm thời được chuyển sang ổ đĩa cứng khi chúng không được sử dụng. Ý tưởng rất đơn giản: vì bộ nhớ vật lý nhanh hơn và đắt hơn nhiều so với dung lượng ổ cứng, nên sử dụng tệp để sao lưu các vùng bộ nhớ khi chúng không được sử dụng. Hãy nghĩ đến một hệ thống đang chạy nhiều ứng dụng. Khi một số ứng dụng này không được sử dụng, thay vì giữ toàn bộ các ứng dụng trong bộ nhớ vật lý, kiến trúc bộ nhớ ảo cho phép hệ thống đổ tất cả bộ nhớ đó vào một tập tin và chỉ cần nạp lại nó ngay khi cần thiết. Quá trình này hoàn toàn trong suốt đối với ứng dụng.

 - ở bên trong, phân trang dễ thực hiện trên các hệ thống bộ nhớ ảo. Hệ thống phải duy trì một số loại đo lường khi trang được truy cập lần cuối (bộ xử lý giúp giải quyết vấn đề này) và sử dụng thông tin đó để định vị các trang chưa được sử dụng trong một thời gian. Khi các trang như vậy được đặt, hệ thống có thể xóa nội dung của chúng và ghi thành tệp đồng thời làm mất hiệu lực mục nhập trang của chúng trong ram. Nội dung của các trang này trong bộ nhớ vật lý (ram) sau đó có thể được loại bỏ và không gian có thể được sử dụng cho các mục đích khác.

 - Sau đó, khi các trang bị xóa được truy cập, bộ xử lý sẽ tạo ra Page Faults (vì các mục trong bảng trang của chúng không hợp lệ) và hệ thống sẽ biết rằng chúng đã được paging. Tại thời điểm này, hệ điều hành sẽ truy cập tệp hoán trang (đây là nơi tất cả bộ nhớ được paging lưu trữ) và đọc dữ liệu trở lại vào bộ nhớ.

 - Một trong những tác dụng phụ mạnh mẽ của thiết kế này là các ứng dụng thực sự có thể sử dụng nhiều bộ nhớ hơn nó có, bởi vì hệ thống có thể sử dụng ổ đĩa cứng để lưu trữ thứ cấp bất cứ khi nào không có đủ bộ nhớ vật lý. Trong thực tế, điều này chỉ hoạt động khi các ứng dụng không chủ động sử dụng nhiều bộ nhớ hơn là có sẵn, vì trong trường hợp này hệ thống sẽ phải di chuyển dữ liệu qua lại giữa bộ nhớ vật lý và ổ đĩa cứng. Bởi vì ổ đĩa cứng thường chậm hơn khoảng 1.000 lần so với bộ nhớ vật lý, các tình huống như vậy có thể làm cho các hệ thống chạy cực kỳ chậm.

#### Page Faults

 - Theo quan điểm của bộ vi xử lý, lỗi trang được tạo bất cứ khi nào một địa chỉ bộ nhớ được truy cập không có mục nhập bảng trang hợp lệ. Là người dùng cuối, chúng tôi đã quen với ý nghĩ rằng lỗi trang bằng tin xấu. Cũng giống như nói rằng một loại vi khuẩn tương đương với tin xấu đối với cơ thể con người; Không gì có thể hơn sự thật. Lỗi trang có danh tiếng không tốt vì bất kỳ sự cố hệ thống hoặc chương trình nào thường đi kèm với thông báo cho chúng tôi biết lỗi trang không được giải quyết. Trong thực tế, lỗi trang được kích hoạt hàng ngàn lần mỗi giây trong một hệ thống bình thường. Trong hầu hết các trường hợp, hệ thống xử lý các lỗi trang như một phần của các hoạt động bình thường của nó. Một ví dụ điển hình về lỗi trang hợp pháp là khi một trang được phân trang ra tệp paging và đang được chương trình truy cập. Vì mục nhập có thể lập page của trang không hợp lệ, bộ xử lý tạo ra lỗi trang, hệ điều hành này giải quyết bằng cách tải nội dung của trang từ tệp paging và tiếp tục chương trình đã kích hoạt lỗi ban đầu.

#### bộ làm việc. 

 - Bộ làm việc là cấu trúc dữ liệu theo từng quy trình liệt kê các trang vật lý hiện tại đang được sử dụng trong không gian địa chỉ của quy trình. Hệ thống này sử dụng các bộ làm việc để xác định việc sử dụng bộ nhớ vật lý của mỗi quá trình và các trang bộ nhớ nào chưa được truy cập trong một thời gian. Các trang như vậy sau đó có thể được phân trang ra đĩa và xóa khỏi bộ làm việc của quy trình.

 - Có thể nói rằng việc sử dụng bộ nhớ của một quá trình tại bất kỳ thời điểm nào có thể được đo lường bằng tổng kích thước của bộ làm việc của nó. Điều đó nói chung là đúng, nhưng là một chút của sự đơn giản hóa vì các khối lượng lớn của không gian địa chỉ quy trình trung bình chứa bộ nhớ dùng chung, cũng được tính là một phần của tổng kích thước bộ làm việc. Việc đo sử dụng bộ nhớ trong một hệ thống bộ nhớ ảo không phải là một nhiệm vụ tầm thường!

#### Kernel Memory and User Memory

 - Có lẽ khái niệm quan trọng nhất trong quản lý bộ nhớ là sự phân biệt giữa bộ nhớ hạt nhân và bộ nhớ người dùng. Được biết, để tạo ra một hệ điều hành mạnh mẽ, các ứng dụng không được truy cập vào các cấu trúc dữ liệu nội bộ của hệ điều hành. Đó là bởi vì chúng tôi không muốn một lỗi của một lập trình viên duy nhất ghi đè lên một số cấu trúc dữ liệu quan trọng và làm mất ổn định toàn bộ hệ thống. Ngoài ra, chúng tôi muốn đảm bảo rằng phần mềm độc hại không thể kiểm soát hệ thống hoặc gây hại cho hệ thống bằng cách truy cập các cấu trúc dữ liệu hệ điều hành quan trọng.

 - Windows sử dụng địa chỉ bộ nhớ 32 bit (4 gigabyte) thường được chia thành hai phần 2 GB: phần bộ nhớ ứng dụng 2 GB và phần bộ nhớ hạt nhân chia sẻ 2 GB. Có một số trường hợp mà các hệ thống 32 bit sử dụng bố cục bộ nhớ khác nhau, nhưng chúng không phổ biến. Ý tưởng chung là trên 2 GB chứa tất cả bộ nhớ liên quan đến hạt nhân trong hệ thống và được chia sẻ giữa tất cả các không gian địa chỉ. Điều này thuận tiện vì nó có nghĩa là bộ nhớ hạt nhân luôn có sẵn, bất kể quá trình nào hiện đang chạy. Dĩ nhiên, 2 GB trên được bảo vệ khỏi mọi quyền truy cập chế độ người dùng.

 - Một hiệu ứng phụ của thiết kế này là các ứng dụng chỉ có một không gian địa chỉ 31 bit — bit quan trọng nhất luôn luôn trống trong mọi địa chỉ. Điều này cung cấp một gợi ý đảo ngược nhỏ: Một số 32 bit có chữ số thập lục phân đầu tiên là 8 hoặc cao hơn không phải là một con trỏ chế độ người dùng hợp lệ.

#### Không gian bộ nhớ hạt nhân

 - Vì vậy, những gì đi vào bên trong những 2 GB dành riêng cho hạt nhân? Những 2 GB được chia giữa các thành phần hạt nhân khác nhau. Chủ yếu, không gian hạt nhân chứa tất cả mã hạt nhân của hệ thống, bao gồm cả hạt nhân và bất kỳ thành phần hạt nhân nào khác trong hệ thống như trình điều khiển thiết bị và tương tự. Hầu hết 2 GB được chia cho một số thành phần hệ thống quan trọng. Việc phân chia nói chung là tĩnh, nhưng có một số khóa registry có thể phần nào ảnh hưởng đến kích thước của một số khu vực này. Hình 3.1 cho thấy cách bố trí điển hình của không gian địa chỉ hạt nhân Windows. Hãy nhớ rằng hầu hết các thành phần có một kích thước động có thể được xác định trong thời gian chạy dựa trên bộ nhớ vật lý có sẵn và trên một số khóa registry có thể cấu hình người dùng.
 <ul>
 <li> **Paged and Nonpaged Pools** Các paged pool và nonpaged pool về cơ bản là kernel-mode heaps được sử dụng bởi tất cả các thành phần kernel. Bởi vì chúng được lưu trữ trong bộ nhớ hạt nhân, các pool vốn đã có sẵn trong tất cả các không gian địa chỉ, nhưng chỉ có thể truy cập từ mã chế độ kernel. pool phân trang là một heap (khá lớn) được tạo thành từ bộ nhớ phân trang thông thường. Các paged pool là heap phân bổ mặc định cho hầu hết các thành phần kernel. Nonpaged pool là một heap được tạo thành từ bộ nhớ nonpageable. Bộ nhớ không thể kết nối có nghĩa là dữ liệu không bao giờ có thể được xả vào ổ đĩa cứng và luôn được giữ trong bộ nhớ vật lý. Điều này có lợi vì các khu vực quan trọng của hệ thống không được phép sử dụng bộ nhớ có thể truy cập được.</li>
 <li> **System Cache** Không gian bộ đệm hệ thống là nơi trình quản lý bộ nhớ cache của Windows ánh xạ tất cả các tệp hiện đang được lưu trong bộ nhớ cache. Caching được thực hiện trong Windows bằng cách ánh xạ các tệp vào bộ nhớ và cho phép người quản lý bộ nhớ quản lý lượng bộ nhớ vật lý được cấp phát cho mỗi tệp được ánh xạ. Khi một chương trình mở một tệp, một đối tượng phần (xem bên dưới) được tạo cho nó, và nó được ánh xạ vào vùng bộ nhớ cache của hệ thống. Khi chương trình truy cập vào tệp sau bằng cách sử dụng API `ReadFile`hoặc `WriteFile`, hệ thống tệp sẽ truy cập nội bộ vào bản sao được ánh xạ của tệp bằng cách sử dụng các API trình quản lý bộ nhớ cache như `CcCopyRead` và `CcCopyWrite`.</li>
 </ul>
 

![3.1](https://i.imgur.com/zPF4nzW.png)

**hình 3.1** Bố trí điển hình của không gian địa chỉ bộ nhớ hạt nhân Windows.
 <ul>
 <li> **Không gian phiên dịch vụ đầu cuối**  Khu vực bộ nhớ này được sử dụng bởi các thành phần chế độ hạt nhân của hệ thống con Win32: `WIN32K.SYS` (xem phần trên hệ thống con Win32 sau này trong chương này). Thành phần dịch vụ đầu cuối là một dịch vụ Windows cho phép nhiều phiên GUI từ xa trên một hệ thống Windows duy nhất. Để thực hiện tính năng này, Microsoft đã tạo không gian bộ nhớ Win32 “phiên riêng tư”, để hệ thống về cơ bản có thể tải nhiều phiên bản của hệ thống con Win32. Trong hạt nhân, mỗi cá thể được nạp vào cùng một địa chỉ ảo, nhưng trong một không gian phiên khác. Không gian phiên chứa tệp thực thi `WIN32K.SYS` và các cấu trúc dữ liệu khác nhau được yêu cầu bởi hệ thống con Win32. Ngoài ra còn có một pool phiên đặc biệt, mà về cơ bản là một phiên cá nhân phân trang pool cũng nằm trong khu vực này.</li>
 <li> **Bảng trang và không gian Hyper** Hai vùng này chứa dữ liệu quy trình cụ thể xác định không gian địa chỉ của quy trình hiện tại. Vùng bảng trang chỉ đơn giản là ánh xạ bộ nhớ ảo của các bảng trang hiện đang hoạt động. Không gian Hyper được sử dụng cho nhiều thứ, nhưng chủ yếu để lập bản đồ bộ làm việc của quy trình hiện tại.</li>
 <li> ** System Working Set** "Bộ làm việc hệ thống" là cấu trúc dữ liệu toàn cầu của hệ thống quản lý việc sử dụng bộ nhớ vật lý của hệ thống (chỉ dành cho bộ nhớ có thể thu thập). Nó là cần thiết vì phần lớn nội dung của không gian địa chỉ bộ nhớ hạt nhân có thể được đánh số trang, do đó hệ thống phải có cách theo dõi các trang hiện đang được sử dụng. Hai vùng bộ nhớ lớn nhất được quản lý bởi cấu trúc dữ liệu này là nhóm phân trang và bộ đệm hệ thống.</li>
 <li> **System Page-Table Entries (PTE)** Đây là một khu vực rộng lớn được sử dụng cho phân bổ hạt nhân lớn của bất kỳ loại nào. Đây không phải là một đống, mà chỉ là một không gian bộ nhớ ảo có thể được sử dụng bởi nhân và trình điều khiển bất cứ khi nào họ cần một phần lớn bộ nhớ ảo, cho bất kỳ mục đích nào. Bên trong, hạt nhân sử dụng không gian Hệ thống PTE để lập bản đồ thực thi trình điều khiển thiết bị và để lưu trữ ngăn xếp hạt nhân (có một cho mỗi luồng trong hệ thống). Trình điều khiển thiết bị có thể phân bổ vùng Hệ thống PTE bằng cách gọi API hạt nhân `MmAllocateMappingAddress`.</li>
 </ul>

#### Section Objects

 - section object là một phần tử quan trọng của trình quản lý bộ nhớ Windows. Nói chung một section object là một đoạn bộ nhớ đặc biệt được quản lý bởi hệ điều hành. Trước khi nội dung của một section object có thể được truy cập, đối tượng phải được ánh xạ. Ánh xạ một section object có nghĩa là một dải địa chỉ ảo được cấp phát cho đối tượng và sau đó nó có thể truy cập được thông qua phạm vi địa chỉ đó.

 - Một trong những thuộc tính chính của các section object là chúng có thể được ánh xạ tới nhiều nơi. Điều này làm cho section object thành một công cụ thuận tiện cho các ứng dụng để chia sẻ bộ nhớ giữa chúng. Hệ thống cũng sử dụng các section object để chia sẻ bộ nhớ giữa các tiến trình hạt nhân và chế độ người dùng. Điều này được thực hiện bằng cách ánh xạ cùng một section object vào cả không gian địa chỉ hạt nhân và một hoặc nhiều không gian địa chỉ chế độ người dùng. Cuối cùng, cần lưu ý rằng thuật ngữ “section object” là khái niệm hạt nhân - trong Win32 (và trong hầu hết tài liệu của Microsoft) chúng được gọi là các tệp ánh xạ bộ nhớ. Có hai loại section object cơ bản:
 <ul>
 <li> **Pagefile-Backed** Đối tượng phần pagefile-backed có thể được sử dụng để lưu trữ tạm thời thông tin và thường được tạo cho mục đích chia sẻ dữ liệu giữa hai tiến trình hoặc giữa các ứng dụng và hạt nhân. Phần này được tạo ra trống, và có thể được ánh xạ tới bất kỳ không gian địa chỉ nào (cả trong bộ nhớ người dùng và bộ nhớ hạt nhân). Giống như bất kỳ vùng bộ nhớ phân trang nào khác, một phần pagefile-backed có thể được phân trang ra một tệp trang nếu cần.</li>
 <li>**File-Backed** Một đối tượng phần file-backed được gắn vào một tệp vật lý trên ổ đĩa cứng. Điều này có nghĩa rằng khi nó được ánh xạ đầu tiên, nó sẽ chứa nội dung của tập tin mà nó được đính kèm. Nếu nó có thể ghi, bất kỳ thay đổi nào được thực hiện cho dữ liệu trong khi đối tượng được ánh xạ vào bộ nhớ sẽ được ghi lại vào tệp. Đối tượng phần Afile-backed là một cách thuận tiện để truy cập một tệp, bởi vì thay vì sử dụng các API cồng kềnh như `ReadFile` và `WriteFile`, một chương trình chỉ có thể truy cập trực tiếp dữ liệu trong bộ nhớ bằng cách sử dụng một con trỏ. Hệ thống sử dụng các đối tượng phần File-Backed cho nhiều mục đích khác nhau, bao gồm tải các file thực thi.</li>
 </ul>

#### VAD Trees 

 - Cây 'DESCRIPTOR VIRTUAL ADDRESS DESCRIPTOR (VAD) là cấu trúc dữ liệu được Windows sử dụng để quản lý phân bổ địa chỉ của từng quá trình riêng lẻ. Cây VAD là cây nhị phân mô tả mọi dải địa chỉ hiện đang được sử dụng. Mỗi quá trình có cây riêng của nó, và trong các cây đó mỗi mục mô tả việc phân bổ bộ nhớ được đề cập. Nói chung, có hai loại phân bổ riêng biệt: *mapped allocations* và *private allocations*. Phân bổ được ánh xạ là các tệp ánh xạ bộ nhớ được ánh xạ vào không gian địa chỉ. Điều này bao gồm tất cả các tệp thực thi được nạp vào không gian địa chỉ tiến trình và mọi tệp ánh xạ bộ nhớ (đối tượng phần) được ánh xạ vào không gian địa chỉ. Phân bổ riêng là phân bổ được xử lý riêng và được phân bổ cục bộ. Phân bổ riêng thường được sử dụng cho heap và ngăn xếp (có thể có nhiều ngăn xếp trong một quy trình duy nhất — mỗi ngăn xếp cho mỗi luồng).

#### Phân bổ chế độ người dùng

 - Hãy xem những gì diễn ra trong không gian địa chỉ chế độ người dùng. Tất nhiên chúng ta không thể cụ thể như chúng ta đã thảo luận trước đây về không gian địa chỉ hạt nhân mà mỗi ứng dụng khác nhau. Tuy nhiên, điều quan trọng là phải hiểu cách các ứng dụng sử dụng bộ nhớ và cách phát hiện các loại bộ nhớ khác nhau.

 **Private Allocations** Phân bổ riêng là loại cấp phát bộ nhớ cơ bản nhất trong một tiến trình. Đây là trường hợp đơn giản mà một ứng dụng yêu cầu một khối bộ nhớ bằng cách sử dụng `VirtualAlloc Win32 API`. Đây là kiểu phân bổ bộ nhớ nguyên thủy nhất, bởi vì nó chỉ có thể phân bổ toàn bộ các trang và không có gì nhỏ hơn. Phân bổ riêng thường được sử dụng bởi hệ thống để phân bổ ngăn xếp và heap (xem bên dưới).

 **Heaps** Hầu hết các ứng dụng Windows không trực tiếp gọi `VirtualAlloc—` thay vào đó chúng phân bổ một khối heap bằng cách gọi một hàm thư viện thời gian thực như `malloc` hoặc bằng cách gọi một API heap hệ thống như `HeapAlloc.` Một heap là một cấu trúc dữ liệu cho phép tạo ra nhiều khối bộ nhớ được biến đổi trong một khối lớn hơn. Interally, một heap cố gắng quản lý bộ nhớ sẵn sàng một cách khôn ngoan để các ứng dụng có thể thuận tiện phân bổ và giải phóng các khối có kích thước biến theo yêu cầu. Hệ điều hành này cung cấp các heap riêng của mình thông qua các API `HeapAlloc` và `HeapFree` Win32, nhưng một ứng dụng cũng có thể thực hiện các vùng riêng của mình bằng cách phân bổ trực tiếp các khối riêng bằng cách sử dụng API `VirtualAlloc`.

 **Stacks** Ngăn xếp chế độ người dùng thường là phân bổ riêng hợp pháp và hệ thống phân bổ một ngăn xếp tự động cho mọi luồng trong khi nó đang được tạo.

 **Executables** Một loại phân bổ chung khác là phân bổ thực thi được ánh xạ. Hệ thống chạy mã ứng dụng bằng cách tải nó vào bộ nhớ dưới dạng tệp ánh xạ bộ nhớ ( memory-mapped file).

 **Mapped Views (Sections)** Ứng dụng có thể tạo các tệp ánh xạ bộ nhớ và ánh xạ chúng vào không gian địa chỉ của chúng. Đây là một phương pháp thuận tiện và thường được sử dụng để chia sẻ bộ nhớ giữa hai hoặc nhiều chương trình.

#### Memory Management APIs

 - Trình quản lý bộ nhớ ảo của Windows có thể truy nhập tới các ứng dụng của chương trình bằng cách sử dụng một tập hợp các API Win32 mà trực tiếp phân bổ và khối lượng bộ nhớ miễn phí trong không gian địa chỉ người dùng. Sau đây là bộ nhớ quản lý cấp thấp Win32 API phổ biến.
 <ul>
 <li>**VirtualAlloc** :Chức năng này phân bổ một khối bộ nhớ riêng trong một không gian địa chỉ chế độ người dùng. Đây là khối bộ nhớ mức thấp có kích thước phải được căn chỉnh theo trang; đây không phải là khối heap có kích thước thay đổi, chẳng hạn như khối được phân bổ bởi `malloc` (hàm thư viện thời gian chạy thư viện C). Một khối có thể được dành riêng hoặc thực sự ủy thác. dành riêng một khối có nghĩa là chúng tôi chỉ đơn giản là đặt trước vùng địa chỉ nhưng không thực sự sử dụng hết bộ nhớ. ủy thác một khối có nghĩa là chúng tôi thực sự phân bổ không gian cho nó trong tệp trang hệ thống. Không có bộ nhớ vật lý nào được sử dụng cho đến khi bộ nhớ thực sự được truy cập.</li>
 <li>** VirtualProtect:** Chức năng này đặt các cài đặt bảo vệ của vùng bộ nhớ, chẳng hạn như liệu khối có thể đọc được, có thể ghi hoặc thực thi được (các phiên bản Windows mới hơn thực sự ngăn chặn việc thực hiện các khối không thể thực hiện được). Cũng có thể sử dụng chức năng này để thay đổi các cài đặt cấp thấp khác, chẳng hạn như khối có được lưu trữ bởi phần cứng hay không, v.v.</li>
 <li>**VirtualQuery:** Chức năng này truy vấn khối bộ nhớ hiện tại (về cơ bản truy xuất thông tin cho nút VAD của khối) để biết các chi tiết khác nhau như loại khối đó (phân bổ riêng, phiên hoặc hình ảnh), và cho dù được dành riêng, ủy thác hoặc không sử dụng .</li>
 <li> **VirtualFree:** Hàm này giải phóng một khối phân bổ riêng (giống như các phân bổ được cấp phát bằng `VirtualAlloc`).</li>
 </ul>

 - Tất cả các API này phân phối không gian địa chỉ hiện đang hoạt động, nhưng Windows cũng hỗ trợ các hoạt động bộ nhớ ảo trên các quy trình khác, nếu quá trình này đủ đặc quyền để thực hiện điều đó. Tất cả các API được liệt kê ở đây có một phiên bản Ex (VirtualAllocEx, VirtualQueryEx,…) nhận được một xử lý cho một đối tượng quá trình và có thể hoạt động trên các vùng địa chỉ của các tiến trình khác với các tiến trình hiện đang chạy. Là một phần của cùng chức năng đó, Windows cũng cung cấp hai API thực sự truy cập vào không gian địa chỉ của một quy trình khác và có thể đọc hoặc ghi vào nó. Các API này là `ReadProcessMemory` và `WriteProcessMemory`.

 - Một nhóm các API quản lý bộ nhớ quan trọng khác là các API đối tượng phiên. Trong Win32 một đối tượng phiên được gọi là một tệp ánh xạ bộ nhớ và có thể được tạo bằng cách sử dụng API `CreateFileMapping`. Một đối tượng phiên có thể được ánh xạ vào không gian địa chỉ chế độ người dùng bằng cách sử dụng API `MapViewOfFileEx` và có thể được unmapped bằng cách sử dụng API `UnmapViewOfFile`.

### Đối tượng và xử lý.

 - Nhân Windows quản lý các đối tượng bằng cách sử dụng một thành phần quản lý đối tượng tập trung. Trình quản lý đối tượng chịu trách nhiệm cho tất cả các đối tượng hạt nhân như các phần, tệp và các đối tượng thiết bị, các đối tượng đồng bộ hóa, các quy trình và các luồng. Điều quan trọng là phải hiểu rằng thành phần này chỉ quản lý các đối tượng liên quan đến hạt nhân. Các đối tượng liên quan đến GUI như cửa sổ, menu và ngữ cảnh thiết bị được quản lý bởi các trình quản lý đối tượng riêng biệt được triển khai bên trong WIN32K.SYS. Chúng được thảo luận trong phần trên hệ thống con Win32 ở phần sau của chương này.

 - Xem xét các đối tượng từ chế độ người dùng, như hầu hết các ứng dụng làm, cung cấp cho họ một hào quang hơi bí ẩn. Điều quan trọng là phải hiểu rằng dưới cấp đó, tất cả các đối tượng này chỉ đơn thuần là các cấu trúc dữ liệu - chúng thường được lưu trữ trong bộ nhớ hạt nhân của nonpaged pool. Tất cả các đối tượng sử dụng tiêu đề đối tượng tiêu chuẩn mô tả các thuộc tính đối tượng cơ bản như loại, số tham chiếu, tên, v.v. Trình quản lý đối tượng không nhận thức được bất kỳ cấu trúc dữ liệu đối tượng cụ thể nào, chúng chỉ nhận biết theo tiêu đề chung.

 - Mã hạt nhân thường truy cập các đối tượng bằng cách sử dụng con trỏ trực tiếp đến cấu trúc dữ liệu đối tượng, nhưng các chương trình ứng dụng rõ ràng không thể làm điều đó. Thay vào đó, các ứng dụng sử dụng các chốt để truy cập các đối tượng riêng lẻ. Một xử lý là một số định danh cụ thể của quy trình mà về cơ bản là một chỉ mục trong bảng xử lý riêng của quy trình. Mỗi mục trong bảng điều khiển chứa một con trỏ tới đối tượng nằm bên dưới, đó là cách mà hệ thống liên kết với các đối tượng. Cùng với con trỏ đối tượng, mỗi mục nhập xử lý cũng chứa một mặt nạ truy cập xác định loại hoạt động nào có thể được thực hiện trên đối tượng bằng cách sử dụng xử lý cụ thể này. Hình 3.2 minh họa cách mà mỗi tiến trình có bảng xử lý riêng của chúng và cách chúng trỏ đến các đối tượng thực tế trong bộ nhớ hạt nhân.

 - Mặt nạ truy cập của đối tượng là một số nguyên 32 bit được chia thành hai từ cờ truy cập 16 bit. Từ trên chứa các cờ truy cập chung như `GENERIC_READ` và `GENERIC_WRITE`. Từ thấp hơn chứa các cờ đặc trưng của đối tượng như `PROCESS_TERMINATE`, cho phép bạn chấm dứt một tiến trình bằng cách sử dụng tay cầm của nó, hoặc `KEY_ENUMERATE_SUB_KEYS`, cho phép bạn liệt kê các khóa con của một khóa thanh ghi mở. Tất cả các tham số quyền truy cập được định nghĩa trong WinNT.H trong SDK nền tảng của Microsoft.

 - Đối với mỗi đối tượng, hạt nhân duy trì hai số tham chiếu: số lượng tham chiếu hạt nhân và số lượng xử lý. Các đối tượng chỉ bị xóa khi chúng có tham chiếu hạt nhân bằng 0 và xử lý bằng 0.

#### Named objects

 - Một số đối tượng hạt nhân có thể được đặt tên, cung cấp một cách để nhận dạng duy nhất chúng trên toàn hệ thống. Giả sử rằng hai quy trình quan tâm đến việc đồng bộ hóa một hoạt động nhất định giữa chúng. Một cách tiếp cận điển hình là sử dụng một đối tượng mutex, nhưng làm thế nào cả hai có thể biết rằng họ đang đối phó với cùng một mutex? Hạt nhân hỗ trợ tên đối tượng như một phương tiện nhận dạng cho các đối tượng riêng lẻ. Trong ví dụ của chúng tôi, cả hai quy trình có thể thử tạo một mutex có tên MyMutex. Bất cứ ai làm điều đó đầu tiên sẽ thực sự tạo ra đối tượng MyMutex, và chương trình thứ hai sẽ chỉ mở một handle mới cho đối tượng. Điều quan trọng là sử dụng một tên chung có hiệu quả đảm bảo rằng cả hai quy trình đang xử lý cùng một đối tượng. Khi một API tạo đối tượng như `CreateMutex` được gọi cho một đối tượng đã tồn tại, hạt nhân sẽ tự động định vị đối tượng đó trong bảng toàn cục và trả về một handle cho nó.

 ![img 3.2](https://i.imgur.com/Mrtu0LI.png)

 - Các đối tượng được đặt tên được sắp xếp trong các thư mục phân cấp, nhưng API Win32 hạn chế quyền truy cập của các ứng dụng chế độ người dùng vào các thư mục này. Dưới đây là danh sách các thư mục thú vị nhất:
 <ul>
 <li>**BaseNamedObjects: ** Thư mục này là nơi tất cả các đối tượng được đặt tên Win32 thông thường, chẳng hạn như mutexes, được lưu trữ. Tất cả các đối tượng Win32 API được đặt tên sẽ tự động sử dụng thư mục này — các chương trình ứng dụng không có quyền kiểm soát điều này.</li>
 <li>**Devices: ** Thư mục này chứa các đối tượng thiết bị cho tất cả các thiết bị hệ thống hiện đang hoạt động. Nói chung, mỗi trình điều khiển thiết bị có ít nhất một mục nhập trong thư mục này, ngay cả những mục không được kết nối với bất kỳ thiết bị vật lý nào. Điều này bao gồm các thiết bị logic như Tcp và các thiết bị vật lý như **Harddisk0**. Win32 API không bao giờ có thể truy cập trực tiếp đối tượng trong thư mục này - chúng phải sử dụng các liên kết tượng trưng (xem bên dưới).</li>
 <li>**GLOBAL??** Thư mục này (còn được đặt tên ?? trong các phiên bản cũ của Windows) là thư mục liên kết tượng trưng. Các liên kết tượng trưng là các tên kiểu cũ cho các đối tượng hạt nhân. Đặt tên kiểu cũ về bản chất là lược đồ đặt tên DOS, mà bạn chắc chắn đã sử dụng. Hãy suy nghĩ về việc gán mỗi ổ đĩa một chữ cái, chẳng hạn như C :, và về việc truy cập các thiết bị vật lý bằng cách sử dụng tên 8 ký tự kết thúc bằng dấu hai chấm, chẳng hạn như COM1 :. Đây là tất cả các tên DOS, và trong các phiên bản Windows hiện đại, chúng được liên kết với các thiết bị thực trong thư mục Devices bằng các liên kết tượng trưng. Các ứng dụng Win32 chỉ có thể truy cập các thiết bị sử dụng tên liên kết tượng trưng của chúng.</li>
 </ul>

 - Một số đối tượng hạt nhân không được đặt tên và chỉ được xác định bởi các handle của chúng hoặc các đối tượng hạt nhân. Một ví dụ tốt về một đối tượng như vậy là một đối tượng thread, được tạo ra không có tên và chỉ được biểu diễn bằng các handle (từ chế độ người dùng) và bởi một con trỏ trực tiếp vào đối tượng (từ chế độ hạt nhân).

### Processes and Threads.

 - Các tiến trình và luồng là cả hai đơn vị cấu trúc cơ bản trong Windows, và điều quan trọng là bạn hiểu chính xác những gì chúng đại diện. Các phần sau đây mô tả các khái niệm cơ bản về các quy trình và luồng và tiến hành thảo luận chi tiết về cách chúng được triển khai trong Windows.

#### Quy trình

 - Một quá trình là một khối xây dựng cơ bản trong Windows. Một quá trình là nhiều thứ, nhưng nó chủ yếu là một không gian địa chỉ bộ nhớ bị cô lập. Không gian địa chỉ này có thể được sử dụng để chạy một chương trình và không gian địa chỉ được tạo cho mỗi chương trình để đảm bảo rằng mỗi chương trình chạy trong không gian địa chỉ riêng của nó. Bên trong không gian địa chỉ của một quá trình hệ thống có thể tải các mô-đun mã, nhưng để thực sự chạy một chương trình, một quá trình phải có ít nhất một luồng chạy.

#### luồng.

 - Một luồng là một đơn vị thực thi mã nguyên thủy. Tại bất kỳ thời điểm nào, mỗi bộ xử lý trong hệ thống đang chạy một luồng, có nghĩa là nó chỉ chạy một đoạn mã; đây có thể là mã chương trình hoặc mã hệ điều hành, điều đó không quan trọng. Ý tưởng với chủ đề là thay vì tiếp tục chạy một đoạn mã duy nhất cho đến khi nó được hoàn thành, Windows có thể quyết định làm gián đoạn chuỗi đang chạy tại bất kỳ thời điểm nào và chuyển sang một luồng khác. Quá trình này là trung tâm của khả năng của Windows để đạt được đồng thời.

 - có thể làm cho nó dễ dàng hơn để hiểu những gì chủ đề được nếu bạn xem xét cách chúng được thực hiện bởi hệ thống. Trong nội bộ, một luồng không có gì ngoài cấu trúc dữ liệu có cấu trúc dữ liệu CONTEXT cho hệ thống biết trạng thái của bộ xử lý khi luồng cuối cùng chạy, kết hợp với một hoặc hai khối bộ nhớ được sử dụng cho không gian ngăn xếp. Khi bạn nghĩ về nó, một luồng giống như một bộ xử lý ảo nhỏ có ngữ cảnh riêng và ngăn xếp riêng của nó. Bộ xử lý vật lý thực chuyển đổi giữa nhiều bộ xử lý ảo và luôn bắt đầu thực hiện từ thông tin ngữ cảnh hiện tại của luồng và sử dụng ngăn xếp của luồng.

 - Lý do mà một luồng có thể có hai ngăn xếp là trong các luồng Windows luân phiên giữa việc chạy mã chế độ người dùng và mã chế độ lõi. Ví dụ, một chuỗi ứng dụng điển hình chạy trong chế độ người dùng, nhưng nó có thể gọi vào các API hệ thống được thực hiện trong chế độ lõi. Trong trường hợp này, mã API hệ thống chạy trong chế độ hạt nhân từ bên trong chuỗi đang gọi! Vì luồng có thể chạy ở cả chế độ người dùng và chế độ hạt nhân, nó phải có hai ngăn xếp: một cho khi nó chạy trong chế độ người dùng và một cho khi nó đang chạy ở chế độ hạt nhân. Tách ngăn xếp là yêu cầu bảo mật cơ bản và mạnh mẽ. Nếu mã chế độ người dùng có quyền truy cập vào ngăn xếp hạt nhân thì hệ thống sẽ dễ bị tấn công bởi nhiều tấn công nguy hiểm và sự ổn định của nó có thể bị tổn hại bởi các lỗi ứng dụng có thể ghi đè lên các phần của ngăn xếp hạt nhân.

 - Các thành phần quản lý các luồng trong Windows là bộ lịch trình và bộ điều phối, cùng nhau chịu trách nhiệm quyết định chuỗi nào sẽ chạy trong bao lâu và để thực hiện chuyển đổi ngữ cảnh thực khi thời gian thay đổi luồng hiện đang chạy.

 - Một khía cạnh thú vị của kiến trúc Windows kernel là preemptive và interruptible, có nghĩa là một thread thường có thể bị gián đoạn trong khi đang chạy trong chế độ hạt nhân giống như nó có thể bị gián đoạn trong khi đang chạy trong chế độ người dùng. Ví dụ, hầu như mọi Win32 API đều bị gián đoạn, như hầu hết các thành phần hạt nhân bên trong. Không ngạc nhiên, có một số thành phần hoặc các khu vực mã không thể bị gián đoạn (nghĩ về điều gì sẽ xảy ra nếu bản thân lịch trình bị gián đoạn ...), nhưng đây thường là những đoạn mã rất ngắn.

#### Context Switching

 - Đôi khi người ta thấy khó có thể hình dung được quá trình làm thế nào một hạt nhân đa luồng đạt được đồng thời với nhiều luồng, nhưng nó thực sự khá đơn giản. Bước đầu tiên là cho hạt nhân để cho một thread chạy. Tất cả điều này có nghĩa trong thực tế là tải ngữ cảnh của nó (điều này có nghĩa là nhập vào không gian địa chỉ bộ nhớ chính xác và khởi tạo các giá trị của tất cả các thanh ghi CPU) và để nó bắt đầu chạy. Chủ đề sau đó chạy bình thường trên bộ xử lý (hạt nhân hiện không thực hiện bất kỳ điều gì đặc biệt tại thời điểm này), cho đến thời điểm chuyển sang một luồng mới. Trước khi chúng ta thảo luận về quá trình chuyển đổi thực tế của bối cảnh, hãy nói về cách thức và lý do một luồng bị gián đoạn.

 - Sự thật là các luồng thường tự bản thân chúng từ bỏ CPU , và hạt nhân thậm chí không phải thực sự làm gián đoạn chúng. Điều này xảy ra bất cứ khi nào một chương trình đang chờ đợi điều gì đó. Trong Windows, một trong những ví dụ phổ biến nhất là khi một chương trình gọi API `GetMessageWin32`. `GetMessage` được gọi mọi lúc - đó là cách ứng dụng yêu cầu hệ thống nếu người dùng đã tạo ra bất kỳ sự kiện đầu vào mới nào (chẳng hạn như chạm vào chuột hoặc bàn phím). Trong hầu hết các trường hợp, `GetMessage` truy cập hàng đợi thư và chỉ trích xuất sự kiện tiếp theo, nhưng trong một số trường hợp, không có bất kỳ thư nào trong hàng đợi. Trong những trường hợp như vậy, `GetMessage` chỉ cần chuyển sang chế độ chờ và không trả lại cho đến khi có sẵn đầu vào người dùng mới. Một cách hiệu quả những gì xảy ra tại thời điểm này là `GetMessage` đang nói với kernel: "Bây giờ tôi đã xong, hãy đánh thức tôi khi một sự kiện đầu vào mới xuất hiện." Tại thời điểm này, hạt nhân lưu toàn bộ trạng thái bộ xử lý và chuyển sang một trạng thái khác chủ đề. Điều này có ý nghĩa rất nhiều bởi vì người ta không muốn bộ vi xử lý chỉ dừng lại vì một chương trình duy nhất không hoạt động vào lúc này — có lẽ các chương trình khác có thể sử dụng CPU.

 - Tất nhiên, GetMessage chỉ là một ví dụ - có hàng chục trường hợp khác. Hãy xem xét ví dụ những gì xảy ra khi một ứng dụng thực hiện một hoạt động I / O chậm như đọc dữ liệu từ mạng hoặc từ một thiết bị lưu trữ tương đối chậm như DVD. Thay vì chỉ đợi thao tác hoàn thành, hạt nhân sẽ chuyển sang chạy một luồng khác trong khi phần cứng đang thực hiện thao tác. Sau đó, hạt nhân quay trở lại để chạy luồng đó khi thao tác hoàn tất.

 - Điều gì sẽ xảy ra khi một chuỗi không chỉ từ bỏ bộ vi xử lý? Điều này có thể dễ dàng xảy ra nếu nó chỉ có rất nhiều việc phải làm. Hãy suy nghĩ về một chủ đề thực hiện một số loại thuật toán phức tạp liên quan đến hàng tỷ phép tính. Mã như vậy có thể mất nhiều giờ trước khi từ bỏ CPU - và về mặt lý thuyết có thể làm kẹt toàn bộ hệ thống. Để tránh các vấn đề như vậy, các hệ điều hành sử dụng những gì được gọi là lập kế hoạch ưu tiên, có nghĩa là các luồng được cấp một khoảng thời gian hạn chế để chạy trước khi chúng bị gián đoạn.

 - Mỗi luồng được gán một lượng tử, là lượng thời gian tối đa mà thread được phép chạy liên tục. Trong khi luồng đang chạy, hệ điều hành sử dụng bộ đếm thời gian phần cứng cấp thấp gián đoạn để theo dõi thời gian đang chạy. Khi lượng tử của luồng lên, nó tạm thời bị gián đoạn và hệ thống cho phép các luồng khác chạy. Nếu không có chủ đề nào khác cần CPU, chuỗi đó sẽ được tiếp tục ngay lập tức. Quá trình đình chỉ và nối lại luồng hoàn toàn trong suốt với luồng - hạt nhân lưu trữ trạng thái của tất cả thanh ghi CPU trước khi tạm dừng luồng và khôi phục trạng thái đó khi luồng được nối lại. Bằng cách này, các luồng không có ý tưởng đó là đã từng bị gián đoạn.

#### đồng bộ hóa các đối tượng

 - Đối với các nhà phát triển phần mềm, sự tồn tại của threads là một hạnh phúc hỗn hợp. Một mặt, threads cung cấp sự linh hoạt đáng kể khi phát triển một chương trình; mặt khác, việc đồng bộ hóa nhiều luồng trong cùng một chương trình là không dễ dàng, đặc biệt là vì chúng hầu như luôn chia sẻ cấu trúc dữ liệu giữa chúng. Có lẽ một trong những khía cạnh quan trọng nhất của việc thiết kế phần mềm đa luồng là làm thế nào để thiết kế đúng cấu trúc dữ liệu và cơ chế khóa sẽ đảm bảo hiệu lực dữ liệu mọi lúc.

 - Thiết kế cơ bản của tất cả các đối tượng đồng bộ hóa là chúng cho phép hai hoặc nhiều chủ đề cạnh tranh cho một tài nguyên duy nhất, và chúng giúp đảm bảo rằng chỉ một số luồng được kiểm soát thực sự truy cập tài nguyên tại bất kỳ thời điểm nào. Các luồng bị chặn được đặt trong trạng thái chờ đặc biệt bởi hạt nhân và không được gửi đi cho đến khi trạng thái chờ đó được thỏa mãn. Đây là lý do tại sao các đối tượng đồng bộ hóa được thực hiện bởi hệ điều hành; người lên lịch phải biết về sự tồn tại của họ để biết khi nào trạng thái chờ đã được thỏa mãn và một luồng cụ thể có thể tiếp tục thực hiện.

 - Windows hỗ trợ một số đối tượng đồng bộ có sẵn, mỗi đối tượng phù hợp với các loại cấu trúc dữ liệu cụ thể cần được bảo vệ. Sau đây là những cách được sử dụng phổ biến nhất:
 <ul>
 <li>**Events** Một sự kiện là một đối tượng đồng bộ hóa Boolean đơn giản có thể được đặt thành True hoặc False. Một sự kiện được chờ đợi bởi một trong các API chờ Win32 tiêu chuẩn như `WaitForSingleObject` hoặc `WaitForMultipleObjects`.</li>
 <li>**Mutexes** Một mutex (từ loại trừ lẫn nhau) là một đối tượng chỉ có thể được mua bởi một luồng tại bất kỳ thời điểm nào. Bất kỳ threads nào cố gắng để có được một mutex trong khi nó đã được sở hữu bởi thread khác sẽ nhập một trạng thái chờ đợi cho đến khi thread gốc giải phòng mutex hoặc cho đến khi nó kết thúc. Nếu có nhiều hơn một chuỗi đang chờ, mỗi người sẽ nhận được quyền sở hữu của mutex theo thứ tự ban đầu mà họ đã yêu cầu.</li>
 <li>**Semaphores** Một semaphore giống như một mutex với một truy cập do người dùng định nghĩa xác định có bao nhiêu chủ sở hữu đồng thời được phép trên nó. Khi số lượng tối đa đó vượt quá, một chuỗi yêu cầu quyền sở hữu của semaphore sẽ nhập trạng thái chờ cho đến khi một trong các chủ đề giải phóng semaphore.</li>
 <li>**Critical Sections** Một phần quan trọng về bản chất là một thực hiện tối ưu hóa một mutex. Nó giống hệt với một mutex, nhưng với sự khác biệt rằng nó là quá trình riêng tư và hầu hết nó được thực hiện trong chế độ người dùng. Tất cả các đối tượng đồng bộ hóa được mô tả ở trên được quản lý bởi trình quản lý đối tượng của hạt nhân và được thực hiện trong chế độ hạt nhân, có nghĩa là hệ thống phải chuyển đổi thành hạt nhân cho bất kỳ thao tác nào cần thực hiện trên chúng. Một phần quan trọng được thực hiện trong chế độ người dùng và hệ thống chỉ chuyển sang chế độ hạt nhân nếu cần chờ đợi thực sự.</li>
 </ul>

#### Process Initialization Sequence

 - Trong nhiều trải nghiệm đảo ngược, tôi nhận thấy rằng điều quan trọng là phải hiểu được điều gì xảy ra khi quá trình được bắt đầu. Phần sau đây mô tả ngắn gọn các bước được thực hiện bởi hệ thống trong một trình tự tạo quy trình liên tục.
 <ul>
 <li> 1. Việc tạo ra đối tượng quy trình và không gian địa chỉ mới là bước đầu tiên: Khi một quá trình gọi API `CreateProcess` của Win32, API tạo một đối tượng quy trình và phân bổ một không gian địa chỉ bộ nhớ mới cho tiến trình.</li>
 <li> 2. `CreateProcess` ánh xạ `NTDLL.DLL` và chương trình thực thi (tệp .exe) vào không gian địa chỉ mới được tạo ra.</li>
 <li> 3. `CreateProcess` tạo luồng đầu tiên của quy trình và phân bổ không gian ngăn xếp cho nó.</li>
 <li> 4. The process’s first thread is resumed and starts running in the `LdrpInitialize` function inside `NTDLL.DLL`.</li>
 <li> 5. `LdrpInitialize` đệ quy đi qua các bảng và bản đồ nhập của tệp thực thi chính vào bộ nhớ mọi tệp thực thi được yêu cầu để chạy tệp thi hành chính.</li>
 <li> 6. Tại thời điểm này điều khiển được thông qua vào `LdrpRunInitializeRoutines`, đó là một phần bên trong `NTDLL.DLL` thường xuyên chịu trách nhiệm khởi tạo tất cả các DLL liên kết tĩnh hiện đang được nạp vào không gian địa chỉ. Quá trình khởi tạo bao gồm gọi từng điểm vào của DLL với hằng số `DLL_PROCESS_ATTACH`.</li>
 <li> 7. Khi tất cả các tệp DLL được khởi tạo, LdrpInitialize gọi tiến trình khởi tạo thực của luồng, đó là hàm `BaseProcessStart` từ `KERNEL32.DLL`. Chức năng này lần lượt gọi điểm truy cập `WinMain` của thực thi, tại thời điểm đó quá trình đã hoàn thành chuỗi khởi tạo của nó.</li>
 </ul>

### Application Programming Interfaces

 - APPLICATION PROGRAMMING INTERFACE (API) là một tập hợp các chức năng mà hệ điều hành có sẵn cho các chương trình ứng dụng để giao tiếp với hệ điều hành. Nếu bạn định đảo ngược với Windows, bạn bắt buộc phải hiểu rõ về các API của Windows và các phương pháp phổ biến để làm việc bằng cách sử dụng các API này.
